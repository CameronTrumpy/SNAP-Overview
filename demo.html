<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNAP - DEMO MODE - ALL IN ONE ELECTRONICS WORKBENCH</title>
    <link rel="icon" type="image/x-icon" href="https://eecs.umich.edu/courses/eng100/Pic/brehob.jpg">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap');

        :root {
            --bg-900: #030712;
            --bg-800: #050b18;
            --bg-700: #0d1627;
            --bg-600: #14203b;
            --card: rgba(11, 20, 36, 0.85);
            --card-strong: rgba(12, 28, 53, 0.95);
            --text-primary: #f8fafc;
            --text-muted: #94a3b8;
            --border-color: rgba(148, 163, 184, 0.25);
            --border-soft: rgba(148, 163, 184, 0.12);
            --accent-cyan: #22d3ee;
            --accent-blue: #6366f1;
            --accent-amber: #fbbf24;
            --accent-emerald: #34d399;
            --radius-lg: 24px;
            --radius-md: 16px;
            --shadow-lg: 0 25px 80px rgba(2, 6, 23, 0.75);
        }

        html {
            background-color: #030712;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: radial-gradient(circle at top, #0f253c 0%, #050b18 45%, #030712 100%);
            background-color: #030712;
            min-height: 100vh;
            padding: 24px;
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                radial-gradient(circle at 20% 20%, rgba(34, 211, 238, 0.18), transparent 45%),
                radial-gradient(circle at 80% 0%, rgba(99, 102, 241, 0.18), transparent 50%),
                radial-gradient(circle at 10% 80%, rgba(251, 191, 36, 0.12), transparent 55%);
            pointer-events: none;
            z-index: 0;
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(90deg, rgba(255, 255, 255, 0.025) 1px, transparent 1px),
                linear-gradient(0deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 80px 80px;
            opacity: 0.2;
            mix-blend-mode: screen;
            pointer-events: none;
            z-index: 0;
        }

        .dashboard {
            width: min(1600px, 100%);
            background: rgba(4, 9, 20, 0.9);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            position: relative;
            z-index: 1;
            backdrop-filter: blur(20px);
            height: auto;
            /* allow height to grow */
            min-height: 100%;
            /* full page if content small */
        }

        .hero {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 10px;
            padding: 16px;
            background: linear-gradient(135deg, rgba(12, 22, 44, 0.85), rgba(6, 12, 26, 0.95));
            border-bottom: 1px solid var(--border-soft);
        }

        .hero-text {
            flex: 1 1 320px;
            min-width: 280px;
        }

        .eyebrow {
            font-size: 0.85rem;
            letter-spacing: 0.28em;
            text-transform: uppercase;
            color: var(--accent-cyan);
            margin-bottom: 0px;
        }

        .hero h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: clamp(2.4rem, 4vw, 3.8rem);
            font-weight: 600;
            margin-bottom: 0px;
            letter-spacing: -0.03em;
        }

        .hero-subtitle {
            color: var(--text-muted);
            font-size: 0.75rem;
            line-height: 1.6;
            max-width: 560px;
        }

        .hero-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-pill {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 18px 20px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(34, 211, 238, 0.4);
            background: rgba(8, 47, 73, 0.4);
            min-width: 240px;
        }

        .status-label {
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .status-pill strong {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.2rem;
            font-weight: 500;
        }

        .content {
            padding: 32px 40px 40px;
            background: linear-gradient(180deg, rgba(3, 7, 18, 0.2), rgba(3, 7, 18, 0.05));
            align-items: flex-start;
        }

        .content-col {
            display: grid;
            grid-template-columns: minmax(0, 2fr) 360px;
            gap: 32px;
            padding: 32px 40px 40px;
            background: linear-gradient(180deg, rgba(3, 7, 18, 0.2), rgba(3, 7, 18, 0.05));
            align-items: flex-start;
        }

        .main-column {
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        .telemetry-column {
            position: sticky;
            top: 32px;
            height: fit-content;
        }

        .section {
            background: var(--card);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-soft);
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: inset 0 1px rgba(255, 255, 255, 0.03);
        }

        .oscope-section {
            background: var(--card);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-soft);
            padding: 28px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: inset 0 1px rgba(255, 255, 255, 0.03);
            width: fit-content;
            /* <-- Let content define width */
            max-width: none;
            /* <-- Remove width cap */
            align-self: flex-start;
            /* <-- Prevent column flex from stretching it */
        }

        .oscope-section h2 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.4rem;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;

            user-select: none;
        }

        .section h2 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.4rem;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--text-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;

            user-select: none;
        }

        .collapse-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .section-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: hidden;
            max-height: 2000px;
            opacity: 1;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
        }

        .module-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 14px;
        }

        .status-tile {
            background: rgba(5, 13, 27, 0.85);
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 14px 16px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-height: 70px;
        }

        .status-tile .status-label {
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 0.24em;
            color: var(--text-muted);
        }

        .status-value {
            font-size: 1.1rem;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-primary);
        }

        .status-value::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(148, 163, 184, 0.6);
            box-shadow: 0 0 6px rgba(148, 163, 184, 0.6);
        }

        .status-value.status-good {
            color: var(--accent-emerald);
        }

        .status-value.status-good::before {
            background: var(--accent-emerald);
            box-shadow: 0 0 8px rgba(52, 211, 153, 0.8);
        }

        .status-value.status-warn {
            color: var(--accent-amber);
        }

        .status-value.status-warn::before {
            background: var(--accent-amber);
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.7);
        }

        .status-value.status-bad {
            color: #f87171;
        }

        .status-value.status-bad::before {
            background: #f87171;
            box-shadow: 0 0 8px rgba(248, 113, 113, 0.9);
        }

        .config-section {
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid var(--border-soft);
            border-radius: 14px;
            padding: 20px 24px;
        }

        .config-section h3 {
            font-size: 0.95rem;
            letter-spacing: 0.18em;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        .input-group {
            display: flex;
            flex-wrap: wrap;
            row-gap: 14px;
            margin-bottom: 12px;
            /* or 14, 16, etc */
            align-items: center;
        }

        .input-group label {
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }

        select,
        input[type="number"] {
            flex: 1;
            min-width: 180px;
            max-width: 320px;
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            padding: 12px 16px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            background: rgba(10, 18, 35, 0.85);
            color: var(--text-primary);
            transition: border 0.2s ease, box-shadow 0.2s ease;
        }

        select:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 3px rgba(34, 211, 238, 0.2);
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 26px;
        }

        button {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            padding: 14px 18px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.02);
            color: var(--text-primary);
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.25s ease, border 0.25s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 20px rgba(15, 23, 42, 0.6);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .ghost-btn {
            background: transparent;
            border-color: rgba(148, 163, 184, 0.4);
        }

        .ghost-btn:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
            box-shadow: 0 12px 30px rgba(34, 211, 238, 0.15);
        }

        .connect-btn {
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.2), rgba(14, 165, 233, 0.08));
            border-color: rgba(34, 211, 238, 0.4);
            box-shadow: 0 12px 30px rgba(14, 165, 233, 0.25);
        }

        .psu-btn-off {
            border-color: rgba(248, 113, 113, 0.5);
            background: radial-gradient(circle at top, rgba(248, 113, 113, 0.22), rgba(67, 20, 7, 0.4));
        }

        .psu-btn-on {
            border-color: rgba(52, 211, 153, 0.5);
            background: radial-gradient(circle at top, rgba(52, 211, 153, 0.22), rgba(5, 46, 22, 0.5));
        }

        .waveform-btn {
            border-color: rgba(251, 191, 36, 0.5);
            background: radial-gradient(circle at top, rgba(251, 191, 36, 0.2), rgba(64, 29, 7, 0.5));
        }

        .waveform-btn-red {
            border-color: rgba(248, 113, 113, 0.5);
            background: radial-gradient(circle at top, rgba(248, 113, 113, 0.22), rgba(67, 20, 7, 0.4));
        }

        .la-btn {
            border-color: rgba(99, 102, 241, 0.55);
            background: radial-gradient(circle at top, rgba(99, 102, 241, 0.22), rgba(32, 22, 68, 0.6));
        }

        .os-btn {
            border-color: rgba(99, 102, 241, 0.55);
            background: radial-gradient(circle at top, rgba(99, 102, 241, 0.22), rgba(32, 22, 68, 0.6));
        }

        .os-btn.stoppolling {
            border-color: rgba(248, 113, 113, 0.5);
            background: radial-gradient(circle at top, rgba(248, 113, 113, 0.22), rgba(67, 20, 7, 0.4));
        }


        .btn-compact {
            padding: 10px 14px;
            font-size: 0.85rem;
        }

        .psu-btn {
            border-color: rgba(99, 102, 241, 0.5);
            background: radial-gradient(circle at top, rgba(99, 102, 241, 0.2), rgba(32, 22, 68, 0.5));
        }

        .psu-profile-item {
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid var(--border-soft);
            background: rgba(15, 23, 42, 0.5);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .psu-profile-item:hover {
            background: rgba(20, 30, 50, 0.7);
            border-color: var(--accent-cyan);
        }

        .psu-profile-item[active] {
            background: rgba(7, 83, 236, 0.7);
            border-color: var(--accent-cyan);
        }

        .psu-profile-item.fixed {
            border-left: 3px solid var(--accent-emerald);
        }

        .psu-profile-item.pps {
            border-left: 3px solid var(--accent-blue);
        }

        .psu-profile-item.avs {
            border-left: 3px solid var(--accent-amber);
        }

        .psu-profile-specs {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .waveform-panel {
            display: none;
            flex-direction: column;
            gap: 16px;
        }

        .waveform-panel.visible {
            display: flex;
        }

        .waveform-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .toolbar-meta {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .toolbar-meta h3 {
            font-size: 1rem;
            font-family: 'Space Grotesk', sans-serif;
        }

        .sample-meta {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-top: 4px;
        }

        .toolbar-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        #waveformCanvas {
            width: 100%;
            height: 300px;
            background: var(--bg-700);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
            cursor: grab;
        }

        .helper-text {
            color: var(--text-muted);
            font-size: 0.85rem;
            letter-spacing: 0.05em;
        }

        .center-buttons {
            display: flex;
            justify-content: center;
            /* <-- Center horizontally */
            gap: 12px;
            /* Space between buttons */
            width: 100%;
        }


        .response-box {
            background: var(--card-strong);
            border: 1px solid var(--border-soft);
            border-radius: 18px;
            padding: 24px;
            max-height: 400px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
        }

        .response-box::-webkit-scrollbar {
            width: 6px;
        }

        .response-box::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.3);
            border-radius: 10px;
        }

        .response-box::-webkit-scrollbar-thumb {
            background: rgba(99, 102, 241, 0.5);
            border-radius: 10px;
        }

        .response-item {
            position: relative;
            padding: 16px 18px 16px 30px;
            border-radius: 14px;
            border: 1px solid var(--border-soft);
            background: rgba(10, 17, 32, 0.9);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
            animation: slideIn 0.3s ease;
        }

        .response-item::before {
            content: '';
            position: absolute;
            left: 14px;
            top: 22px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent-blue);
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.7);
        }

        .response-item.success {
            border-color: rgba(34, 197, 94, 0.6);
        }

        .response-item.success::before {
            background: var(--accent-emerald);
            box-shadow: 0 0 10px rgba(52, 211, 153, 0.7);
        }

        .response-item.error {
            border-color: rgba(248, 113, 113, 0.5);
        }

        .response-item.error::before {
            background: #f87171;
            box-shadow: 0 0 10px rgba(248, 113, 113, 0.7);
        }

        .response-time {
            color: var(--text-muted);
            font-size: 0.75rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .response-message {
            color: var(--text-primary);
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .response-data {
            color: var(--accent-blue);
            font-size: 0.82rem;
            line-height: 1.6;
            padding: 12px;
            border-radius: 10px;
            background: rgba(4, 9, 20, 0.95);
            border: 1px solid rgba(99, 102, 241, 0.2);
            max-height: 320px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .placeholder-text {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .status-indicator {
            display: inline-block;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #f87171;
            box-shadow: 0 0 12px rgba(248, 113, 113, 0.8);
            position: relative;
            animation: pulse 2.4s infinite;
        }

        .status-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.6;
            transform: translate(-50%, -50%);
            animation: ripple 2.4s infinite;
        }

        .status-indicator.connected {
            background: var(--accent-emerald);
            box-shadow: 0 0 14px rgba(52, 211, 153, 0.8);
        }

        .status-indicator.unstable {
            background: var(--accent-amber);
            box-shadow: 0 0 14px rgba(216, 169, 14, 0.8);
        }

        /* ============================================
   NEW LAYOUT: Left Sidebar Tabs + Right Panels
   ============================================ */

        /* Make header tiny */
        /* .hero {
    padding: 6px 14px;
    background: rgba(12, 22, 44, 0.6);
    height: 32px;
    display: flex;
    align-items: center;
    border-bottom: 1px solid var(--border-soft);
} */

        .hero-actions {
            margin-left: auto;
        }

        /* Overall layout */
        /* .content {
    display: grid;
    grid-template-rows: 240px 1fr;
    gap: 0;
    padding: 0;
    background: none;
} */

        /* Left tabs column */
        .sidebar-tabs {
            background: var(--bg-800);
            border-right: 1px solid var(--border-soft);
            padding-top: 20px;
            display: flex;
            flex-direction: row;
            gap: 6px;
            height: 80px;
        }

        .tab-btn {
            padding: 8px 10px;
            border-radius: 0;
            background: transparent;
            border-left: 4px solid transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 1rem;
            text-align: left;
            color: var(--text-muted);
            cursor: pointer;
            transition: 0.25s;
        }

        .tab-btn:hover {
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-primary);
        }

        .tab-btn.active {
            border-bottom: 4px solid var(--accent-cyan);
            background: rgba(34, 211, 238, 0.07);
            color: var(--text-primary) !important;
        }

        /* Right content area */
        .tab-content-area {
            padding: 32px;
            overflow-x: auto;
            height: calc(100vh - 40px);
        }

        /* Hide all tab panels initially */
        .tab-panel {
            display: none;
        }

        /* Show active tab */
        .tab-panel.active {
            display: block;
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .oscope-controls {
            display: flex;
            flex-direction: column;
            gap: 14px;
            align-items: center;

            width: fit-content;
            /* <-- Let content define width */
            max-width: none;
            /* <-- Remove width cap */
            align-self: flex-start;
            /* <-- Prevent column flex from stretching it */
        }

        /* Telemetry oscilloscope display area */
        #oscopeTelemetry canvas {
            width: 100%;
            border-radius: 14px;
            background: var(--bg-700);
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
        }

        #scopeCanvas {
            width: 100%;
            height: 300px;
            background: #000000;
            border: 1px solid #1f2937;
            border-radius: 4px;
            display: block;
        }

        /* Special layout when the Oscilloscope is active */
        /* When Oscilloscope tab is active, restructure the layout */
        .content-col.oscope-active {
            grid-template-columns: 330px 1fr;
            /* thin left control column, big right area */
        }

        /* The telemetry column becomes the full oscilloscope display area */
        .content-col.oscope-active .telemetry-column {
            position: static;
            /* no sticky in oscope mode */
            width: 100%;
        }

        /* The left main column becomes narrow (control panel) */
        .content-col.oscope-active .main-column {
            max-width: 260px;
        }





        /* Adjust sections to fit right area better */
        .section {
            margin-bottom: 24px;
        }

        @media (max-width: 1100px) {
            .content-col {
                grid-template-columns: 1fr;
                /* stack main + telemetry */
            }

            .telemetry-column {
                position: static;
                /* no sticky when stacked */
                margin-top: 24px;
                /* little gap under main */
            }
        }

        @media (max-width: 1100px) {
            .content {
                grid-template-rows: 1fr;
                padding: 14px;
            }

            .telemetry-column {
                position: static;
            }
        }

        @media (max-width: 640px) {
            body {
                padding: 16px;
            }

            .hero {
                padding: 1px;
            }

            .content {
                padding: 24px;
            }

            .input-group {
                flex-direction: column;
                align-items: flex-start;
            }

            select,
            input[type="number"],
            button {
                width: 100%;
                max-width: 100%;
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(12px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        @keyframes ripple {
            0% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(2.5);
            }
        }

        .demo-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #f59e0b 0%, #ef4444 100%);
            color: white;
            text-align: center;
            padding: 8px 16px;
            font-weight: 600;
            z-index: 9999;
            font-size: 0.9rem;
            letter-spacing: 0.1em;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        body {
            padding-top: 64px !important;
        }
    </style>
</head>

<body>
    <div class="demo-banner">DEMO MODE</div>

    <div class="dashboard">
        <header class="hero">
            <div class="hero-text">
                <p class="eyebrow">Integrated electronics workbench</p>
                <h1>SNAP Command Deck</h1>
                <p class="hero-subtitle">EECS 473 Group 14</p>
            </div>
            <div class="hero-actions">
                <div class="status-pill">
                    <span class="status-indicator" id="statusIndicator" aria-live="polite"
                        aria-label="Device disconnected"></span>
                    <div>
                        <p class="status-label">Workbench Link</p>
                        <strong id="statusLabel">Disconnected</strong>
                    </div>
                </div>
                <button class="ghost-btn" onclick="refreshPorts()">Refresh Ports</button>
            </div>

        </header>


        <div class="content">
            <div class="sidebar-tabs">
                <button class="tab-btn active" data-target="panel-connection">Device Connection</button>
                <button class="tab-btn" data-target="panel-psu">Power Supply</button>
                <button class="tab-btn" data-target="panel-wf">Waveform Generator</button>
                <button class="tab-btn" data-target="panel-la">Logic Analyzer</button>
                <button class="tab-btn" data-target="panel-scope">Oscilloscope</button>
            </div>


            <div class="content-col">
                <!-- Main Column -->
                <div class="main-column">
                    <!-- Connection Section -->
                    <div id="panel-connection" class="tab-panel active">
                        <div class="section">
                            <h2>
                                <span class="collapse-icon"> </span>
                                <span>Device Connection</span>
                                <span class="collapse-icon"> </span>
                            </h2>

                            <div class="section-content">
                                <div class="config-section">
                                    <h3>Port Selection</h3>
                                    <div class="input-group">
                                        <label for="portSelect">Select Port</label>
                                        <select id="portSelect">
                                            <option value="">Loading ports...</option>
                                        </select>
                                    </div>
                                </div>


                                <div class="config-section">
                                    <h3>USB Performance Test</h3>
                                    <div class="input-group">
                                        <label for="testSizeSelect">Test Size</label>
                                        <select id="testSizeSelect">
                                            <option value="64">64 KB (Quick)</option>
                                            <option value="512" selected>512 KB (Standard)</option>
                                            <option value="2048">2 MB (Full)</option>
                                            <option value="51200">50 MB (Extended)</option>
                                        </select>
                                    </div>
                                    <div class="module-status" style="margin-top: 15px;">
                                        <div class="status-tile">
                                            <span class="status-label">USB Throughput</span>
                                            <span class="status-value" id="usbThroughput">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">Transfer Time</span>
                                            <span class="status-value" id="usbDuration">--</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="button-grid">
                                    <button class="connect-btn" onclick="connectDevice()">Establish
                                        Connection</button>
                                    <button class="ghost-btn" onclick="pingDevice()">Ping Device</button>
                                    <button class="ghost-btn" onclick="testUsbSpeed()">Test USB Speed</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- End Connection Section -->

                    <!-- PSU Section -->
                    <div id="panel-psu" class="tab-panel">

                        <div class="section">
                            <h2>
                                <span class="status-indicator" id="psuIndicator"></span>
                                <span>USB-C Power Supply</span>
                                <span class="collapse-icon"> </span>

                            </h2>


                            <div class="section-content">
                                <div class="config-section">
                                    <h3>Live Telemetry</h3>
                                    <div class="module-status">
                                        <div class="status-tile">
                                            <span class="status-label">Voltage (V)</span>
                                            <span class="status-value" id="psu-voltage-actual">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">Current (A)</span>
                                            <span class="status-value" id="psu-current-actual">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">Current Limit(A)</span>
                                            <span class="status-value" id="psu-current-limit">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">Temperature (°C)</span>
                                            <span class="status-value" id="psu-temp">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">5V Rail</span>
                                            <span class="status-value" id="psu-5v-status">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">3.3V Rail</span>
                                            <span class="status-value" id="psu-3v3-status">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">Adjustable Rail</span>
                                            <span class="status-value" id="psu-pd-status">--</span>
                                        </div>
                                        <div class="status-tile">
                                            <span class="status-label">Requested V</span>
                                            <span class="status-value" id="psu-voltage-req">--</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="config-section" id="PPSConfig" style="display: none;">
                                    <h3>Variable Output Adjustment</h3>
                                    <div class="input-group">
                                        <label for="Voltage">Voltage (V):</label>
                                        <input type="number" id="Voltage" value="5.0" min="0.0" max="20.0" step="0.1"
                                            placeholder="Enter voltage...">
                                        <label for="Currlim">Current Limit (Amps):</label>
                                        <input type="number" id="Currlim" width="100%" value="1.0" min="1.0" max="5"
                                            step="0.25" placeholder="Enter desired current limit...">
                                    </div>
                                </div>


                                <div class="button-grid">
                                    <button id="btn3V" class="psu-btn-off" onclick="toggle3V()">Toggle Fixed 3V</button>
                                    <button id="btn5V" class="psu-btn-off" onclick="toggle5V()">Toggle Fixed 5V</button>
                                    <button id="btnPD" class="psu-btn-off" onclick="togglePDOut()">Toggle Adjustable
                                        Output</button>
                                </div>
                                <button class="psu-btn-on" onclick="configurePSU()">Update PSU Configuration</button>

                                <!-- Capabilities Display Panel -->
                                <div id="psuCapabilitiesPanel" class="config-section"
                                    style="display: none; margin-top: 16px;">
                                    <h3>Available Power Profiles</h3>
                                    <div id="psuCapabilitiesTable">
                                        <!-- Populated dynamically -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- End PSU Stuff -->

                    <!-- Waveform Section -->
                    <div id="panel-wf" class="tab-panel">
                        <div class="section">
                            <h2>
                                <span class="status-indicator" id="wfIndicator" aria-live="polite"
                                    aria-label="WF disconnected"></span>
                                <span>Waveform Generator</span>
                                <span class="collapse-icon"> </span>

                            </h2>

                            <div class="section-content">
                                <div class="module-status">
                                    <div class="status-tile">
                                        <p class="status-label">Current Shape</p>
                                        <p class="status-value status-warn" id="waveformTypeStatus">Idle</p>
                                    </div>
                                    <div class="status-tile">
                                        <p class="status-label">Amplitude</p>
                                        <p class="status-value" id="waveformAmplitudeStatus">—</p>
                                    </div>
                                    <div class="status-tile">
                                        <p class="status-label">Frequency</p>
                                        <p class="status-value" id="waveformFrequencyStatus">—</p>
                                    </div>
                                    <div class="status-tile">
                                        <p class="status-label">Last Update</p>
                                        <p class="status-value" id="waveformUpdateStatus">—</p>
                                    </div>
                                </div>

                                <div class="config-section">
                                    <h3>Waveform Parameters</h3>
                                    <div class="input-group">
                                        <label for="wfAmplitude">Amplitude (V):</label>
                                        <input type="number" id="wfAmplitude" value="1.0" min="0" max="5.0" step="0.1"
                                            placeholder="0.0 - 5.0 V">
                                    </div>
                                    <div class="input-group">
                                        <label for="wfFrequency">Frequency (Hz):</label>
                                        <input type="number" id="wfFrequency" value="10000" min="1" max="100000000"
                                            step="100" placeholder="1 Hz - 100 MHz">
                                    </div>
                                    <div class="input-group">
                                        <label for="wfOffset">Offset (V):</label>
                                        <input type="number" id="wfOffset" value="0.0" min="0" max="5.0" step="0.1"
                                            placeholder="0.0 - 5.0 V">
                                    </div>
                                    <div class="input-group">
                                        <label for="wfPhase">Phase (rad):</label>
                                        <input type="number" id="wfPhase" value="0.0" min="0" max="6.28" step="0.1"
                                            placeholder="0.0 - 2π rad">
                                    </div>
                                    <!-- Pulse-specific parameter -->
                                    <div class="input-group" id="dutyCycleGroup" style="display: none;">
                                        <label for="wfDutyCycle">Duty Cycle (%):</label>
                                        <input type="number" id="wfDutyCycle" value="10.0" min="0" max="100" step="1"
                                            placeholder="0 - 100 %">
                                    </div>
                                    <!-- Ramp-specific parameter -->
                                    <div class="input-group" id="rampDirectionGroup" style="display: none;">
                                        <label for="wfUpwards">Direction:</label>
                                        <select id="wfUpwards">
                                            <option value="true">Upwards ⬆</option>
                                            <option value="false">Downwards ⬇</option>
                                        </select>
                                    </div>
                                    <button class="ghost-btn" onclick="resetWaveformDefaults()"
                                        style="width: 100%; margin-top: 8px;">
                                        ↺ Reset to Defaults
                                    </button>
                                </div>

                                <div class="button-grid">
                                    <button class="waveform-btn" id="btn-sine" onclick="sendWaveform('sine')">〰️
                                        Sine</button>
                                    <button class="waveform-btn" id="btn-square" onclick="sendWaveform('square')">▭
                                        Square</button>
                                    <button class="waveform-btn" id="btn-triangle" onclick="sendWaveform('triangle')">△
                                        Triangle</button>
                                    <button class="waveform-btn" id="btn-ramp" onclick="sendWaveform('ramp')">⟋
                                        Ramp</button>
                                    <button class="waveform-btn" id="btn-pulse" onclick="sendWaveform('pulse')">▮
                                        Pulse</button>
                                    <button class="waveform-btn-red" id="btn-off" onclick="sendWaveform('off')"> OFF
                                    </button>

                                </div>
                            </div>
                        </div>

                    </div>
                    <!-- End Waveform Generator Section -->

                    <!-- Logic Analyzer Section -->
                    <div id="panel-la" class="tab-panel">
                        <div class="section">
                            <h2>
                                <span class="status-indicator" id="laIndicator" aria-live="polite"
                                    aria-label="LA disconnected"></span>
                                <span>Logic Analyzer</span>
                                <span class="collapse-icon"> </span>
                            </h2>

                            <div class="section-content">
                                <div class="module-status">
                                    <div class="status-tile">
                                        <p class="status-label">Sample Rate</p>
                                        <p class="status-value" id="laFrequencyStatus">1.0 MHz</p>
                                    </div>
                                    <div class="status-tile">
                                        <p class="status-label">Capture State</p>
                                        <p class="status-value status-warn" id="laCaptureStatus">Idle</p>
                                    </div>
                                </div>

                                <div class="config-section">
                                    <div class="input-group">
                                        <label for="frequency">Frequency (Hz):</label>
                                        <input type="number" id="frequency" value="100000" min="1" max="100000000"
                                            placeholder="Enter frequency...">
                                        <button class="la-btn" onclick="configureLA()">⚙️ Configure</button>
                                    </div>
                                    <div class="input-group">
                                        <label for="numChunks">Num Chunks:</label>
                                        <input type="number" id="numChunks" value="3" min="1" max="1000"
                                            placeholder="Enter number of chunks...">
                                    </div>
                                </div>

                                <div class="button-grid">
                                    <button class="la-btn" onclick="laStart()">Start Capture</button>
                                    <button class="la-btn" onclick="laStop()">Stop Capture</button>
                                    <button class="la-btn" onclick="laGetChunk()">Get Data Chunk</button>
                                </div>

                                <!-- Waveform visualization canvas -->
                                <div id="waveformContainer" class="waveform-panel">
                                    <div class="waveform-toolbar">
                                        <div class="toolbar-meta">
                                            <h3>Sample Data Visualization</h3>
                                            <p class="sample-meta" id="sampleInfo"></p>
                                        </div>
                                        <div class="toolbar-actions">
                                            <button class="btn-compact la-btn" onclick="zoomIn()">+ Zoom In</button>
                                            <button class="btn-compact la-btn" onclick="zoomOut()">- Zoom Out</button>
                                            <button class="btn-compact la-btn" onclick="resetZoom()">↺ Reset</button>
                                        </div>
                                    </div>
                                    <canvas id="waveformCanvas" width="1200" height="300"></canvas>
                                    <p class="helper-text">Tip: Click and drag to pan • Scroll to zoom • Use buttons
                                        for
                                        precise
                                        control</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- end LA -->


                    <!-- Oscilloscope Section -->
                    <div id="panel-scope" class="tab-panel">
                        <div class="oscope-section">
                            <h2>
                                <span class="status-indicator" id="scopeIndicator"></span>
                                <span>Oscilloscope</span>
                                <span class="collapse-icon"></span>
                            </h2>

                            <!-- LEFT: Thin Control Column -->
                            <div class="oscope-controls">
                                <div class="config-section">
                                    <div class="input-group">
                                        <label for="scopeFreq">Sample Freq (Hz):</label>
                                        <input id="scopeFreq" type="number" value="1000000" style="width:100px;">
                                        <button id="scopeConfigBtn" class="button-grid os-btn">Set</button>
                                    </div>
                                    <div class="input-group">
                                        <label for="scopeSamples">Num Samples:</label>
                                        <input id="scopeSamples" type="number" value="1" style="width:100px;">
                                    </div>
                                </div>

                                <div class="input-group">
                                    <button id="continuousButton" class="button-grid os-btn center-buttons"
                                        onclick="toggleContinuous()">Start Continuous</button>
                                    <!--<button id="scopeStartBtn" class="secondary">Start</button>
                                    <button id="scopeStopBtn" class="secondary">Stop</button>-->
                                    <button id="scopeSingleBtn" class="button-grid os-btn center-buttons">Single
                                        Capture</button>
                                </div>

                                <div class="config-section">
                                    <div class="input-group">
                                        <label for="vdiv">Volts/Div:</label>
                                        <input id="vdiv" type="number" step="0.1" value="1.0" style="width:80px;">
                                    </div>

                                    <div class="input-group">
                                        <label for="tdiv">Samples/Div:</label>
                                        <input id="tdiv" type="number" step="1" value="100" style="width:80px;">
                                    </div>

                                    <div class="input-group">
                                        <button id="autoscaleBtn" class="button-grid os-btn">Autoscale</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- end oscope-->
                </div> <!-- End Main Column -->

                <div class="telemetry-column">
                    <!-- only visible on oscope tab -->
                    <div id="oscopeTelemetry" class="section" style="display:none;">

                        <h2><span class="collapse-icon"></span>Oscilloscope Display<span class="collapse-icon"></span>
                        </h2>
                        <canvas id="scopeCanvas" width="1000" height="300"></canvas>
                    </div>

                    <!-- always visible but will stretch telemetry data when oscope is there-->
                    <div class="section" id="response-log-section">
                        <h2>
                            <span class="collapse-icon"></span>
                            System Log
                            <span class="collapse-icon"></span>
                        </h2>
                        <div class="section-content">
                            <div class="response-box" id="responseBox">
                                <p class="placeholder-text">◆ System ready. Awaiting commands...</p>
                            </div>
                        </div>
                    </div>
                </div> <!-- End Telemetry data  -->

            </div> <!-- End content-col -->
            <!-- Telemetry Column (Right Side) -->

        </div> <!-- End Content area -->

    </div> <!-- End Dashboard  -->

    <!-- ============================================================ -->
    <!-- MOCK API LAYER - DEMO MODE                                   -->
    <!-- ============================================================ -->
    <!-- This section intercepts all API calls and returns simulated  -->
    <!-- data. The rest of the code is identical to index.html.       -->
    <!--                                                               -->
    <!-- To update: Keep this layer isolated. UI changes should be    -->
    <!-- copied from index.html without modification.                 -->
    <!-- ============================================================ -->
    <script>
        console.log('%c SNAP EE Workstation Demo Mode ',
            'background: #22d3ee; color: #030712; font-size: 20px; padding: 10px;');
        console.log('Inspect demo state: MockAPI.state');
        console.log('All data is simulated - no real device required');

        const MockAPI = {
            version: '1.0.0',
            lastSync: '2025-12-03',

            // ===== STATE MANAGEMENT =====
            state: {
                connected: false,
                psuOn: false,
                usbcConnected: true,
                laCapturing: false,
                scopeCapturing: false,

                waveform: {
                    type: 'sine',
                    amplitude: 1.0,
                    frequency: 1000,
                    offset: 0.0,
                    phase: 0.0,
                    duty_cycle: 10.0,
                    upwards: true,
                    lastUpdated: null
                },

                psu: {
                    voltage: 5.0,
                    current_limit: 2.0,
                    pd_slot: 0,
                    f3v_enabled: false,
                    f5v_enabled: true,
                    pd_enabled: true,
                    voltage_actual: 5.0,
                    current_actual: 0.5,
                    temp: 30.0,
                    tempStartTime: null
                },

                la: {
                    frequency: 1000000,
                    num_chunks: 1
                },

                scope: {
                    sample_rate: 100000,
                    num_samples: 1000
                }
            },

            // ===== DYNAMIC DATA GENERATORS =====
            generators: {
                psuTelemetry() {
                    const state = MockAPI.state.psu;

                    // Voltage with small noise around setpoint
                    const voltageNoise = (Math.random() - 0.5) * 0.1;
                    const voltage_actual = state.voltage + voltageNoise;

                    // Current with realistic load variation
                    const timeSec = Date.now() / 1000;
                    const baseLoad = 0.8;
                    const loadVariation = 0.3 * Math.sin(timeSec * 0.5);
                    const current_actual = Math.max(0.1,
                        Math.min(state.current_limit, baseLoad + loadVariation + (Math.random() - 0.5) * 0.1));

                    // Temperature drift
                    if (MockAPI.state.psuOn) {
                        const targetTemp = 45.0;
                        const heatRate = 0.01;
                        state.temp = state.temp + (targetTemp - state.temp) * heatRate;
                    } else {
                        const ambientTemp = 30.0;
                        const coolRate = 0.005;
                        state.temp = state.temp - (state.temp - ambientTemp) * coolRate;
                    }

                    return {
                        req_voltage: state.voltage,
                        req_current_lim: state.current_limit,
                        voltage_actual: voltage_actual,
                        current_actual: current_actual,
                        temp_c: state.temp,
                        selected_profile: state.pd_slot,
                        f5v_enabled: state.f5v_enabled,
                        f3v_enabled: state.f3v_enabled,
                        pd_enabled: state.pd_enabled
                    };
                },

                scopeSamples(numSamples, waveformConfig) {
                    const samples = [];
                    const { type, amplitude, frequency, offset, phase, duty_cycle, upwards } = waveformConfig;
                    const sampleRate = MockAPI.state.scope.sample_rate;
                    const dt = 1.0 / sampleRate;

                    for (let i = 0; i < numSamples; i++) {
                        const t = i * dt;
                        const angle = 2 * Math.PI * frequency * t + phase;
                        let value = 0;

                        switch (type) {
                            case 'sine':
                                value = amplitude * Math.sin(angle) + offset;
                                break;
                            case 'square':
                                value = amplitude * (Math.sin(angle) >= 0 ? 1 : -1) + offset;
                                break;
                            case 'triangle':
                                const trianglePhase = (angle / (2 * Math.PI)) % 1;
                                value = amplitude * (4 * Math.abs(trianglePhase - 0.5) - 1) + offset;
                                break;
                            case 'ramp':
                                const rampPhase = (angle / (2 * Math.PI)) % 1;
                                value = amplitude * (upwards ? (2 * rampPhase - 1) : (1 - 2 * rampPhase)) + offset;
                                break;
                            case 'pulse':
                                const pulsePhase = (angle / (2 * Math.PI)) % 1;
                                value = amplitude * (pulsePhase < duty_cycle / 100 ? 1 : -1) + offset;
                                break;
                            default:
                                value = offset;
                        }

                        // Add small noise
                        value += (Math.random() - 0.5) * 0.05;

                        // Clamp to ±20V range
                        value = Math.max(-20, Math.min(20, value));

                        samples.push(value);
                    }

                    return samples;
                },

                laDigitalData(numBytes) {
                    const data = new Uint8Array(numBytes);
                    const freq = MockAPI.state.la.frequency;

                    for (let i = 0; i < numBytes; i++) {
                        let byte = 0;

                        // Channel 0: Clock signal (10 kHz)
                        const clockPeriod = Math.max(1, Math.floor(freq / 10000));
                        byte |= (Math.floor(i / clockPeriod) % 2) ? 0x01 : 0x00;

                        // Channel 1: Slower clock (1 kHz)
                        const slowClockPeriod = Math.max(1, Math.floor(freq / 1000));
                        byte |= (Math.floor(i / slowClockPeriod) % 2) ? 0x02 : 0x00;

                        // Channel 2: Pseudo-random data
                        byte |= (Math.random() > 0.5) ? 0x04 : 0x00;

                        // Channel 3: SPI CS (active low, periodic bursts)
                        const burstPeriod = 100;
                        const burstActive = (i % burstPeriod) < 10;
                        byte |= burstActive ? 0x00 : 0x08;

                        // Channels 4-7: Various patterns
                        byte |= (i % 3 === 0) ? 0x10 : 0x00;
                        byte |= (i % 5 === 0) ? 0x20 : 0x00;
                        byte |= (i % 7 === 0) ? 0x40 : 0x00;
                        byte |= (Math.floor(i / 50) % 2) ? 0x80 : 0x00;

                        data[i] = byte;
                    }

                    return Array.from(data);
                }
            },

            // ===== API ENDPOINT HANDLERS =====
            endpoints: {
                'GET /api/ports': () => {
                    return {
                        success: true,
                        ports: [
                            { device: 'SNAP DEMO 1', description: 'SNAP EE Workstation Demo Device 1' },
                            { device: 'SNAP DEMO 2', description: 'SNAP EE Workstation Demo Device 2' }
                        ]
                    };
                },

                'POST /api/connect': (body) => {
                    MockAPI.state.connected = true;
                    MockAPI.state.psu.temp = 30.0;
                    const port = body && body.port ? body.port : 'SNAP DEMO 1';
                    console.log('[MOCK API] Connect called with body:', body, 'port:', port);
                    return {
                        success: true,
                        message: `Connected to ${port}`
                    };
                },

                'POST /api/ping': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    const lock_wait_ms = (0.01 + Math.random() * 0.2).toFixed(2);
                    const flush_time_ms = (0.01 + Math.random() * 0.15).toFixed(2);
                    const write_time_ms = (0.02 + Math.random() * 0.3).toFixed(2);
                    const response_wait_ms = (0.05 + Math.random() * 0.4).toFixed(2);
                    const total_time_ms = (parseFloat(lock_wait_ms) + parseFloat(flush_time_ms) + parseFloat(write_time_ms) + parseFloat(response_wait_ms)).toFixed(2);

                    return {
                        success: true,
                        message: 'Pong!',
                        timing: {
                            lock_wait_ms: lock_wait_ms,
                            flush_time_ms: flush_time_ms,
                            write_time_ms: write_time_ms,
                            response_wait_ms: response_wait_ms,
                            total_time_ms: total_time_ms
                        }
                    };
                },

                'POST /api/waveform/sine': (body) => MockAPI.endpoints._waveform('sine', body),
                'POST /api/waveform/square': (body) => MockAPI.endpoints._waveform('square', body),
                'POST /api/waveform/triangle': (body) => MockAPI.endpoints._waveform('triangle', body),
                'POST /api/waveform/ramp': (body) => MockAPI.endpoints._waveform('ramp', body),
                'POST /api/waveform/pulse': (body) => MockAPI.endpoints._waveform('pulse', body),
                'POST /api/waveform/off': (body) => MockAPI.endpoints._waveform('off', body),

                _waveform: (type, body) => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    MockAPI.state.waveform = {
                        type: type,
                        amplitude: body.amplitude || 1.0,
                        frequency: body.frequency || 1000,
                        offset: body.offset || 0.0,
                        phase: body.phase || 0.0,
                        duty_cycle: body.duty_cycle || 10.0,
                        upwards: body.upwards !== undefined ? body.upwards : true,
                        lastUpdated: Date.now()
                    };

                    return {
                        success: true,
                        message: `Waveform set to ${type}`,
                        response: `amp=${body.amplitude}V, freq=${body.frequency}Hz`
                    };
                },

                'POST /api/psu/on': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.psuOn = true;
                    return {
                        success: true,
                        message: 'PSU enabled',
                        response: 'PSU output enabled'
                    };
                },

                'POST /api/psu/off': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.psuOn = false;
                    return {
                        success: true,
                        message: 'PSU disabled',
                        response: 'PSU output disabled'
                    };
                },

                'POST /api/psu/alive': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    // Occasionally simulate USB-C disconnect (very rarely)
                    if (Math.random() < 0.002) {
                        MockAPI.state.usbcConnected = false;
                        setTimeout(() => {
                            MockAPI.state.usbcConnected = true;
                        }, 2000);
                    }

                    return {
                        success: true,
                        status: MockAPI.state.usbcConnected
                    };
                },

                'POST /api/psu/capabilities': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    return {
                        success: true,
                        message: 'PSU capabilities queried',
                        capabilities: [
                            { slot: 0, voltage_max: 5.0, voltage_min: null, current_max: 3.0, power_max: 15.0, type: 'Fixed', valid: true },
                            { slot: 1, voltage_max: 9.0, voltage_min: null, current_max: 3.0, power_max: 27.0, type: 'Fixed', valid: true },
                            { slot: 2, voltage_max: 12.0, voltage_min: null, current_max: 2.25, power_max: 27.0, type: 'Fixed', valid: true },
                            { slot: 3, voltage_max: 15.0, voltage_min: null, current_max: 1.8, power_max: 27.0, type: 'Fixed', valid: true },
                            { slot: 4, voltage_max: 20.0, voltage_min: null, current_max: 1.35, power_max: 27.0, type: 'Fixed', valid: true },
                            { slot: 5, voltage_max: 21.0, voltage_min: 3.3, current_max: 3.0, power_max: 27.0, type: 'PPS', valid: true }
                        ],
                        num_profiles: 6
                    };
                },

                'POST /api/psu/status': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    const telemetry = MockAPI.generators.psuTelemetry();

                    return {
                        success: true,
                        message: 'PSU status queried',
                        status: telemetry
                    };
                },

                'POST /api/psu/config': (body) => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    MockAPI.state.psu.voltage = body.voltage || 5.0;
                    MockAPI.state.psu.current_limit = body.current_limit || 2.0;
                    MockAPI.state.psu.pd_slot = body.pdslot !== undefined ? body.pdslot : 0;
                    MockAPI.state.psu.f3v_enabled = body.f3Ven || false;
                    MockAPI.state.psu.f5v_enabled = body.f5Ven !== undefined ? body.f5Ven : true;
                    MockAPI.state.psu.pd_enabled = body.pdEN !== undefined ? body.pdEN : true;

                    return {
                        success: true,
                        message: 'PSU configured',
                        response: `V=${body.voltage}V, I=${body.current_limit}A`
                    };
                },

                'POST /api/la/start': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.laCapturing = true;
                    return {
                        success: true,
                        message: 'Logic analyzer started',
                        response: 'LA capture started'
                    };
                },

                'POST /api/la/stop': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.laCapturing = false;
                    return {
                        success: true,
                        message: 'Logic analyzer stopped',
                        response: 'LA capture stopped'
                    };
                },

                'POST /api/la/get_chunk': (body) => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    const numChunks = body.num_chunks || 1;
                    const bytesPerChunk = 4096;
                    const totalBytes = numChunks * bytesPerChunk;

                    const dataBytes = MockAPI.generators.laDigitalData(totalBytes);

                    return {
                        success: true,
                        message: `Captured ${dataBytes.length} bytes`,
                        data_bytes: dataBytes,
                        total_bytes: dataBytes.length
                    };
                },

                'POST /api/la/config': (body) => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.la.frequency = body.frequency || 1000000;
                    return {
                        success: true,
                        message: 'LA configured',
                        response: `freq=${body.frequency}Hz`
                    };
                },

                'POST /api/scope/start': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.scopeCapturing = true;
                    return {
                        success: true,
                        message: 'Oscilloscope started',
                        response: 'Scope capture started'
                    };
                },

                'POST /api/scope/stop': () => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.scopeCapturing = false;
                    return {
                        success: true,
                        message: 'Oscilloscope stopped',
                        response: 'Scope capture stopped'
                    };
                },

                'POST /api/scope/get_chunk': (body) => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    const numChunks = body.num_chunks || 1;
                    const samplesPerChunk = 16383;  // 32767 bytes / 2 bytes per sample
                    const totalSamples = numChunks * samplesPerChunk;

                    const samples = MockAPI.generators.scopeSamples(totalSamples, MockAPI.state.waveform);

                    // Convert to hex format (10-bit ADC samples, little-endian)
                    const dataHex = [];
                    for (let i = 0; i < samples.length; i++) {
                        // Convert voltage to ADC value
                        // ADC zero: 546, range: -20V to +20V
                        const adc = Math.round(546 + (samples[i] / 40.0) * 1023);
                        const clampedAdc = Math.max(0, Math.min(1023, adc));

                        // Little-endian: LSB first
                        dataHex.push(clampedAdc & 0xFF);
                        dataHex.push((clampedAdc >> 8) & 0xFF);
                    }

                    return {
                        success: true,
                        message: `Captured ${samples.length} samples`,
                        data_hex: dataHex,
                        total_samples: samples.length
                    };
                },

                'POST /api/scope/config': (body) => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }
                    MockAPI.state.scope.sample_rate = body.frequency || 100000;
                    return {
                        success: true,
                        message: 'Scope configured',
                        response: `freq=${body.frequency}Hz`
                    };
                },

                'POST /api/usb/speed_test': (body) => {
                    if (!MockAPI.state.connected) {
                        return { success: false, message: 'Device not connected' };
                    }

                    const testSizeKb = body.test_size_kb || 512;
                    const totalBytes = testSizeKb * 1024;
                    const throughputMbps = (40 + Math.random() * 10).toFixed(2); // 40-50 MB/s
                    const durationMs = ((totalBytes / (parseFloat(throughputMbps) * 1024 * 1024)) * 1000).toFixed(2);

                    // Generate realistic timing breakdown
                    const lock_wait_ms = (0.05 + Math.random() * 0.1).toFixed(2);
                    const flush_time_ms = (0.1 + Math.random() * 0.2).toFixed(2);
                    const write_time_ms = (parseFloat(durationMs) * 0.95).toFixed(2); // Most time is writing
                    const response_wait_ms = (0.05 + Math.random() * 0.1).toFixed(2);
                    const total_time_ms = parseFloat(durationMs).toFixed(2);

                    return {
                        success: true,
                        message: 'USB speed test completed',
                        throughput_mbps: parseFloat(throughputMbps),
                        duration_ms: parseFloat(durationMs),
                        total_bytes: totalBytes,
                        test_size_kb: testSizeKb,
                        timing: {
                            lock_wait_ms: lock_wait_ms,
                            flush_time_ms: flush_time_ms,
                            write_time_ms: write_time_ms,
                            response_wait_ms: response_wait_ms,
                            total_time_ms: total_time_ms
                        }
                    };
                }
            },

            // ===== MAIN FETCH INTERCEPTOR =====
            async fetch(url, options = {}) {
                // Parse URL and method
                const method = options.method || 'GET';
                const key = `${method} ${url}`;

                // Add realistic delay
                const delay = url.includes('/psu/status') || url.includes('/psu/alive') ? 5 : 20;
                await new Promise(resolve => setTimeout(resolve, delay));

                // Parse request body
                let body = {};
                if (options.body) {
                    try {
                        body = JSON.parse(options.body);
                    } catch (e) {
                        // Body might not be JSON
                    }
                }

                // Handle waveform type parameter
                const waveformMatch = url.match(/\/api\/waveform\/(\w+)/);
                if (waveformMatch) {
                    const waveformType = waveformMatch[1];
                    const handler = MockAPI.endpoints[`POST /api/waveform/${waveformType}`];
                    if (handler) {
                        const result = handler(body);
                        return {
                            ok: result.success,
                            json: async () => result
                        };
                    }
                }

                // Route to endpoint handler
                const handler = MockAPI.endpoints[key];
                if (handler) {
                    const result = handler(body);
                    return {
                        ok: result.success,
                        json: async () => result
                    };
                }

                // Unknown endpoint
                console.warn(`Mock API: Unknown endpoint ${key}`);
                return {
                    ok: false,
                    json: async () => ({ success: false, message: `Unknown endpoint: ${key}` })
                };
            }
        };

        // Global mock fetch function
        async function mockFetch(url, options = {}) {
            return await MockAPI.fetch(url, options);
        }
    </script>

    <!-- ============================================================ -->
    <!-- APPLICATION CODE (Modified from index.html)                  -->
    <!-- ============================================================ -->
    <script>
        //if (window.psuStatusInterval) clearInterval(window.psuStatusInterval);
        //if (window.psuLifeInterval) clearInterval(window.psuLifeInterval);

        //window.psuStatusInterval = setInterval(queryPSUStatus, 5000);
        //window.psuLifeInterval = setInterval(queryPSULife, 5000);

        let isConnected = false;

        let isPDWFConnected = false;
        let isUSBCConnected = false;
        let isLAOSConnected = false;

        let selectedPDSlot = -1;
        let fixed5VEn = false;
        let fixed3VEn = false;
        let PDEn = false;

        let availablePorts = [];


        //==========================
        //      oscope functions
        //==========================
        // Oscilloscope state
        let scopeData = [];
        let scopeRunning = false;
        let scopeAnimId = null;
        let lastSamples = [];
        let isContinuous = false;
        let continuousTimer = null;

        let continuousRunning = false;
        let continuousLoopPromise = null;

        let psuStatusInterval = null;
        let psuLifeInterval = null;
        let psuPollingPaused = false;


        function startPsuPolling() {
            // if (psuPollingPaused) return;      // do nothing if paused by oscope
            // if (psuStatusInterval || psuLifeInterval) return; // already running

            psuStatusInterval = setInterval(queryPSUStatus, 500);

            // Start life polling 5 seconds later, then repeat every 2500ms
            setTimeout(() => {
                if (!psuPollingPaused) {
                    psuLifeInterval = setInterval(queryPSULife, 500);
                }
            }, 250);
        }


        function pausePsuPolling() {
            psuPollingPaused = true;

            if (psuStatusInterval) {
                clearInterval(psuStatusInterval);
                psuStatusInterval = null;
            }
            if (psuLifeInterval) {
                clearInterval(psuLifeInterval);
                psuLifeInterval = null;
            }
        }

        function resumePsuPolling() {
            psuPollingPaused = false;
            startPsuPolling();
        }





        function addLog(line) {
            const responseBox = document.getElementById('responseBox');
            if (!responseBox) return;

            const time = new Date().toLocaleTimeString();

            const item = document.createElement('div');
            item.className = 'response-item success';

            item.innerHTML = `
                <div class="response-time">${time}</div>
                <div class="response-message">${line}</div>
            `;

            // Remove placeholder "Awaiting commands..."
            if (
                responseBox.children.length === 1 &&
                responseBox.textContent.includes('Awaiting commands')
            ) {
                responseBox.innerHTML = '';
            }

            responseBox.insertBefore(item, responseBox.firstChild);

            // Cap at 50 entries
            while (responseBox.children.length > 50) {
                responseBox.removeChild(responseBox.lastChild);
            }
        }

        // function setStatusValue(id, text, cls) {
        //     const el = document.getElementById(id);
        //     if (!el) {
        //     // Fallback: just log it
        //     addLog(`[status:${id}] ${text}`);
        //     return;
        //     }
        //     el.textContent = text;
        //     el.className = 'status-pill ' + cls;
        // }
        function formatFrequency(freqHz) {
            const f = Number(freqHz);
            if (!isFinite(f) || f <= 0) return `${freqHz} Hz`;
            if (f >= 1e6) return (f / 1e6).toFixed(2) + ' MHz';
            if (f >= 1e3) return (f / 1e3).toFixed(2) + ' kHz';
            return f.toFixed(0) + ' Hz';
        }

        function setScopeStatus(text, cls) {
            const el = document.getElementById('scopeStatus');
            el.textContent = text;
            el.className = 'status-pill ' + cls;
        }

        async function osStart() {
            try {
                const response = await mockFetch('/api/scope/start', {
                    method: 'POST'
                });
                const data = await response.json();

                // Log to browser devtools console
                console.log('[OS START RESPONSE]', data);

                // Log to the on-page log window
                addLog(
                    `[${new Date().toISOString()}] /api/scope/start response:\n` +
                    JSON.stringify(data, null, 2)
                );

                if (data.success) {
                    setStatusValue('osCaptureStatus', 'Capturing', 'status-good');
                } else {
                    setStatusValue('osCaptureStatus', 'Start failed', 'status-bad');
                }

                addResponse(
                    data.success ? data.message : data.message,
                    data.response || null,
                    data.success,
                    data
                );
            } catch (error) {
                console.error('[OS START ERROR]', error);
                setStatusValue('osCaptureStatus', 'Start error', 'status-bad');
                addResponse('Error starting OS', error.message, false);
                addLog(
                    `[${new Date().toISOString()}] /api/scope/start ERROR:\n` +
                    String(error)
                );
            }
        }

        async function singleShot() {
            //pausePsuPolling();

            await osStart();
            const samples = await osGetChunk();
            await osStop();

            //resumePsuPolling();

            drawScopeWaveform(samples);
        }

        async function osGetChunk() {
            try {
                lastSamples = null;
                const num_chunks = parseInt(document.getElementById("scopeSamples").value, 10);

                const response = await mockFetch('/api/scope/get_chunk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ num_chunks: num_chunks })
                });

                const data = await response.json();

                if (!data.success || !data.data_hex) return null;

                const samples = parseScopeData(data.data_hex);
                lastSamples = samples;
                console.log(lastSamples.length);

                setStatusValue('osCaptureStatus', `Data ${data.data_hex.length} B`, 'status-good');

                return samples;

            } catch (err) {
                setStatusValue('osCaptureStatus', 'Data error', 'status-bad');
                return null;
            }
        }



        function parseScopeData(dataBytes) {
            if (!Array.isArray(dataBytes)) {
                addLog('parseScopeData: expected array of bytes');
                return [];
            }

            const bytes = Uint8Array.from(dataBytes);
            const samples = [];

            const ADC_ZERO = 546;     // <-- your real 0-volt point
            const FULL_SCALE_VOLTS = 40.0; // –20 to +20 range

            for (let i = 0; i + 1 < bytes.length; i += 2) {

                // 1. Little-endian combine
                let adc = bytes[i] | (bytes[i + 1] << 8);

                // 2. Mask to 10 bits
                adc &= 0x03FF;

                // 3. Shift by zero midpoint
                let shifted = adc - ADC_ZERO;

                // 4. Scale to volts
                let volts = (shifted / 1023.0) * FULL_SCALE_VOLTS;

                samples.push(volts);
            }

            return samples;
        }


        function drawScopeWaveform(samples) {
            const SAMPLE_RATE = parseFloat(document.getElementById("scopeFreq").value);

            const canvas = document.getElementById('scopeCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const vdiv = parseFloat(document.getElementById('vdiv').value);   // volts per division
            const tdiv = parseInt(document.getElementById('tdiv').value, 10); // samples per division

            drawGrid(ctx, w, h);
            drawAxisLabels(ctx, w, h, vdiv, tdiv);

            if (!samples || samples.length === 0) return;

            const divisions = 10;
            const waveformDivisions = divisions - 2;  // center 8 divisions are waveform area

            //
            // === VERTICAL SCALE ===
            //
            const pixelsPerVolt = (h / waveformDivisions) / vdiv;

            //
            // === HORIZONTAL SCALE ===
            //
            const timePerDiv = tdiv / SAMPLE_RATE;         // seconds per division
            const pixelsPerSecond = (w / divisions) / timePerDiv;
            const dt = 1 / SAMPLE_RATE;


            ctx.beginPath();

            let t = 0;  // seconds

            for (let i = 0; i < samples.length; i++) {

                //
                // samples[i] IS ALREADY IN VOLTS  (–20..+20)
                //
                const volts = samples[i];

                // y=0 is top, so invert
                const y = h / 2 - volts * pixelsPerVolt;

                // time → x coordinate
                const x = t * pixelsPerSecond;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);

                t += dt;
            }

            ctx.lineWidth = 1;
            ctx.strokeStyle = "#10b981";
            ctx.stroke();
        }


        function autoscale(samples) {
            console.log("AUTOSCALE CALLED");
            if (!samples || samples.length === 0) return;

            // 1. Find min/max
            let minV = Math.min(...samples);
            let maxV = Math.max(...samples);

            // 2. Ignore very small ranges (noise floor)
            let range = maxV - minV;

            if (range < 0.05) {
                // treat as flat / noisy signal
                range = 0.2; // at least ±0.1V
                minV = -0.1;
                maxV = 0.1;
            }

            // 3. Add padding
            const PADDING_RATIO = 0.25;
            const padding = range * PADDING_RATIO;
            minV -= padding;
            maxV += padding;

            // 4. Final range
            const total = maxV - minV;

            // 5. Compute v/div for 8 waveform divisions
            let vdiv = total / 8;

            // 6. Snap to "nice" oscilloscope values (1, 2, 5 progression)
            vdiv = snapTo125(vdiv);

            // 7. Update UI
            document.getElementById('vdiv').value = vdiv.toFixed(3);

            // 8. Autoscale timebase
            const tdiv = autoscaleTime(samples);
            document.getElementById('tdiv').value = tdiv;

            // 9. Redraw
            drawScopeWaveform(samples);
        }


        function snapTo125(x) {
            const decade = Math.pow(10, Math.floor(Math.log10(x)));
            const norm = x / decade;

            let snapped;
            if (norm < 1.5) snapped = 1;
            else if (norm < 3.5) snapped = 2;
            else if (norm < 7.5) snapped = 5;
            else snapped = 10;

            return snapped * decade;
        }

        function detectPeriod(samples) {
            const N = samples.length;
            if (N < 4) return null;

            // 1. Detect approximate zero (mean) to avoid DC offset messing up crossing detection
            const mean = samples.reduce((a, b) => a + b, 0) / N;

            // 2. Only consider points within ±20% of full range around mean
            //    This filters noise & large DC offsets
            const maxV = Math.max(...samples);
            const minV = Math.min(...samples);
            const threshold = mean;   // crossing point
            const hysteresis = 0.2 * (maxV - minV);  // avoid micro-noise flickers

            let crossings = [];

            for (let i = 1; i < N; i++) {
                let prev = samples[i - 1];
                let cur = samples[i];

                // Rising edge with hysteresis
                if (prev < (threshold - hysteresis) &&
                    cur > (threshold + hysteresis)) {
                    crossings.push(i);
                }
            }

            // Need at least two crossings to determine period
            if (crossings.length < 2) return null;

            // Compute all periods
            let diffs = [];
            for (let i = 1; i < crossings.length; i++) {
                diffs.push(crossings[i] - crossings[i - 1]);
            }

            // Return the median period (more robust vs noise)
            diffs.sort((a, b) => a - b);
            return diffs[Math.floor(diffs.length / 2)];
        }




        function autoscaleTime(samples) {
            const P = detectPeriod(samples);
            if (!P) {
                // fallback if no period detected: show all samples
                return Math.max(Math.floor(samples.length / 10), 1);
            }

            // Target: show ~1.5 cycles across 10 divisions
            let tdiv = (P * 5) / 10;

            // clamp small values
            if (tdiv < 1) tdiv = 1;

            return Math.floor(tdiv);
        }

        function drawGrid(ctx, w, h) {
            const divisions = 10;
            ctx.strokeStyle = "rgba(255,255,255,0.55)";
            ctx.lineWidth = 1;

            for (let i = 0; i <= divisions; i++) {
                const x = (w / divisions) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }

            for (let j = 0; j <= divisions; j++) {
                const y = (h / divisions) * j;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
        }

        function drawAxisLabels(ctx, w, h, vdiv, tdiv) {
            const SAMPLE_RATE = parseFloat(document.getElementById("scopeFreq").value);
            const dt = 1 / SAMPLE_RATE;  // seconds per sample

            ctx.fillStyle = "rgba(255,255,255,0.95)";
            ctx.font = "12px sans-serif";
            const divisions = 10;

            // Y-axis labels (volts)
            ctx.textAlign = "left";
            const voltsPerDiv = vdiv;

            for (let i = 0; i <= divisions; i++) {
                const y = (h / divisions) * i;
                const dv = ((divisions / 2) - i) * voltsPerDiv;
                ctx.fillText(dv.toFixed(1) + " V", 5, y - 2);
            }

            // X-axis labels (sample index)
            // X-axis labels (time)
            ctx.textAlign = "center";

            const samplesPerDiv = tdiv;
            const timePerDivSec = samplesPerDiv / SAMPLE_RATE;

            for (let i = 0; i <= divisions; i++) {
                const x = (w / divisions) * i;
                const tSec = i * timePerDivSec;

                let label;
                if (tSec >= 1) {
                    label = tSec.toFixed(2) + " s";
                } else if (tSec >= 0.001) {
                    label = (tSec * 1000).toFixed(2) + " ms";
                } else {
                    label = (tSec * 1e6).toFixed(2) + " µs";
                }

                ctx.fillText(label, x, h - 5);
            }


            // Label 0V at center
            ctx.textAlign = "right";
            ctx.fillText("0 V", w - 5, h / 2 - 4);
        }

        async function configureOS() {
            // Use the existing "scopeFreq" input (Sample Freq (Hz))
            const frequency = document.getElementById('scopeFreq').value;

            try {
                const response = await mockFetch('/api/scope/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ frequency: Number(frequency) })
                });
                const data = await response.json();

                if (data.success) {
                    setStatusValue('osFrequencyStatus', formatFrequency(frequency), 'status-good');
                } else {
                    setStatusValue('osFrequencyStatus', 'Config error', 'status-bad');
                }

                addResponse(
                    data.success ? data.message : '' + data.message,
                    data.response || null,
                    data.success,
                    data
                );
            } catch (error) {
                setStatusValue('osFrequencyStatus', 'Config error', 'status-bad');
                addResponse('Error configuring OS', error.message, false);
            }
        }

        // async function startContinuous() {
        //     running = true;
        //     await osStart();

        //     while (running) {
        //         const samples = await osGetChunk();
        //         drawScopeWaveform(samples);
        //     }

        //     await osStop();
        // }

        async function toggleContinuous() {
            if (continuousRunning) {
                stopContinuous();   // turn it off
            } else {
                startContinuous();  // turn it on
            }
        }

        async function startContinuous() {
            if (continuousRunning) return; // safety
            //pausePsuPolling();

            continuousRunning = true;
            document.getElementById('continuousButton').textContent = "Stop Continuous";
            document.getElementById('continuousButton').classList.add("stoppolling");

            // start acquisition
            await osStart();

            continuousLoop();  // start async loop (non-blocking)
        }

        async function stopContinuous() {
            if (!continuousRunning) return;

            continuousRunning = false;
            document.getElementById('continuousButton').textContent = "Start Continuous";
            document.getElementById('continuousButton').classList.remove("stoppolling");

            await osStop();
            //resumePsuPolling();
        }

        async function continuousLoop() {
            while (continuousRunning) {

                const samples = await osGetChunk();
                if (!samples) {
                    console.warn("No samples returned; stopping.");
                    stopContinuous();
                    break;
                }

                drawScopeWaveform(samples);

                // yield to event loop (allows UI updates)
                await new Promise(r => setTimeout(r, 0));
            }
        }





        async function osStop() {
            try {
                const response = await mockFetch('/api/scope/stop', {
                    method: 'POST'
                });
                const data = await response.json();

                // Log to browser devtools console
                console.log('[OS STOP RESPONSE]', data);

                // Log to the on-page log window
                addLog(
                    `[${new Date().toISOString()}] /api/scope/stop response:\n` +
                    JSON.stringify(data, null, 2)
                );

                if (data.success) {
                    setStatusValue('osCaptureStatus', 'Idle', 'status-warn');
                } else {
                    setStatusValue('osCaptureStatus', 'Stop failed', 'status-bad');
                }
                isContinuous = false;

                if (continuousTimer) {
                    clearInterval(continuousTimer);
                    continuousTimer = null;
                }

                addResponse(
                    data.success ? data.message : '' + data.message,
                    data.response || null,
                    data.success,
                    data
                );
            } catch (error) {
                console.error('[OS STOP ERROR]', error);
                setStatusValue('osCaptureStatus', 'Stop error', 'status-bad');
                addResponse('Error stopping OS', error.message, false);
                addLog(
                    `[${new Date().toISOString()}] /api/scope/stop ERROR:\n` +
                    String(error)
                );
            }
        }

        function activateTab(targetId) {
            document.querySelector('.content-col').classList.toggle(
                'oscope-active',
                targetId === 'panel-scope'
            );
        }


        //==========================
        //      end oscope functions
        //==========================


        // Toggle section collapse/expand
        function toggleSection(headerElement) {
            const icon = headerElement.querySelector('.collapse-icon');
            const content = headerElement.nextElementSibling;

            if (content && content.classList.contains('section-content')) {
                icon.classList.toggle('collapsed');
                content.classList.toggle('collapsed');
            }
        }

        //switch tabs for modules
        document.querySelectorAll(".tab-btn").forEach(btn => {
            btn.addEventListener("click", () => {

                // button active state
                document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");

                // get target ID
                const target = btn.getAttribute("data-target");

                // show proper panel
                document.querySelectorAll(".tab-panel").forEach(p => p.classList.remove("active"));
                document.getElementById(target).classList.add("active");

                // toggle oscope layout class
                const contentCol = document.querySelector(".content-col");
                if (target === "panel-scope") {
                    contentCol.classList.add("oscope-active");
                } else {
                    contentCol.classList.remove("oscope-active");
                }

                if (target === "panel-psu") {
                    // start PSU polling
                    resumePsuPolling();
                } else {
                    // stop PSU polling
                    pausePsuPolling();
                }

                // Show oscope telemetry only on oscope tab
                document.getElementById("oscopeTelemetry").style.display =
                    (target === "panel-scope") ? "block" : "none";
            });
        });


        function expandSection(headerElement) {
            const icon = headerElement.querySelector('.collapse-icon');
            const content = headerElement.nextElementSibling;

            if (content && content.classList.contains('section-content')) {
                icon.classList.remove('collapsed');
                content.classList.remove('collapsed');
            }
        }

        function collapseSection(headerElement) {
            const icon = headerElement.querySelector('.collapse-icon');
            const content = headerElement.nextElementSibling;

            if (content && content.classList.contains('section-content')) {
                icon.classList.add('collapsed');
                content.classList.add('collapsed');
            }
        }



        // Waveform visualization state
        let allSampleData = [];
        let viewStartSample = 0;
        let samplesPerScreen = 1000;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartSample = 0;
        let rafPending = false;
        let cachedCanvasCtx = null;
        let gridCanvas = null;
        const STATUS_CLASSES = ['status-good', 'status-warn', 'status-bad'];

        // Load ports on page load
        window.addEventListener('DOMContentLoaded', async function () {
            // ----- OSCILLOSCOPE BUTTONS -----
            if (document.getElementById('scopeConfigBtn'))
                document.getElementById('scopeConfigBtn').onclick = configureOS;

            if (document.getElementById('scopeStartContinuosBtn'))
                document.getElementById('scopeStartContinuosBtn').onclick = () => toggleContinuous();

            if (document.getElementById('scopeStartBtn'))
                document.getElementById('scopeStartBtn').onclick = osStart;

            if (document.getElementById('scopeStopBtn'))
                document.getElementById('scopeStopBtn').onclick = osStop;

            if (document.getElementById('scopeSingleBtn'))
                document.getElementById('scopeSingleBtn').onclick = () => singleShot(true);

            if (document.getElementById('autoscaleBtn'))
                document.getElementById('autoscaleBtn').onclick = () => autoscale(lastSamples);

            await refreshPorts();
            setupCanvasInteraction();
            // Auto-connect to default port after loading
            await connectDevice();
            // Send ping to verify connection
            //await pingDevice();
            //initializeModuleStatus();

        });

        function initializeModuleStatus() {
            const voltageInput = document.getElementById('Voltage');
            if (voltageInput) {
                setStatusValue('psuVoltageStatus', formatVoltage(voltageInput.value || 0), 'status-good');
            }
            setStatusValue('psuOutputStatus', 'Standby', 'status-warn');
            setStatusValue('waveformTypeStatus', 'Idle', null);
            setStatusValue('waveformAmplitudeStatus', '—', null);
            setStatusValue('waveformFrequencyStatus', '—', null);
            setStatusValue('waveformUpdateStatus', 'Awaiting command', null);

            const laFrequencyInput = document.getElementById('frequency');
            if (laFrequencyInput) {
                setStatusValue('laFrequencyStatus', formatFrequency(laFrequencyInput.value || 0), null);
            }
            setStatusValue('laCaptureStatus', 'Idle', 'status-warn');
        }


        // Analyzer mode state

        function setStatusValue(elementId, value, stateClass = null) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.textContent = value;
            STATUS_CLASSES.forEach(cls => el.classList.remove(cls));
            if (stateClass) {
                el.classList.add(stateClass);
            }
        }

        function formatVoltage(val) {
            const num = Number(val);
            if (Number.isNaN(num)) return `${val} V`;
            return `${num.toFixed(2)} V`;
        }

        function formatFrequency(val) {
            const num = Number(val);
            if (Number.isNaN(num)) return `${val} Hz`;
            if (num >= 1_000_000_000) {
                return `${(num / 1_000_000_000).toFixed(2)} GHz`;
            } else if (num >= 1_000_000) {
                return `${(num / 1_000_000).toFixed(2)} MHz`;
            } else if (num >= 1_000) {
                return `${(num / 1_000).toFixed(2)} kHz`;
            }
            return `${num} Hz`;
        }

        function formatTimeStamp() {
            const now = new Date();
            return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        function capitalizeWord(word) {
            if (!word) return '';
            return word.charAt(0).toUpperCase() + word.slice(1);
        }

        function setupCanvasInteraction() {
            const canvas = document.getElementById('waveformCanvas');

            // Mouse wheel for zooming (throttled with requestAnimationFrame)
            canvas.addEventListener('wheel', function (e) {
                e.preventDefault();
                if (allSampleData.length === 0) return;
                if (rafPending) return;

                rafPending = true;
                requestAnimationFrame(() => {
                    const zoomFactor = e.deltaY > 0 ? 1.2 : 0.8;
                    const oldSamplesPerScreen = samplesPerScreen;
                    samplesPerScreen = Math.max(100, Math.min(allSampleData.length, samplesPerScreen * zoomFactor));

                    // Zoom towards mouse position
                    const mouseX = e.offsetX;
                    const canvasWidth = canvas.offsetWidth;
                    const mouseRatio = mouseX / canvasWidth;

                    const centerSample = viewStartSample + oldSamplesPerScreen * mouseRatio;
                    viewStartSample = Math.max(0, Math.min(allSampleData.length - samplesPerScreen,
                        centerSample - samplesPerScreen * mouseRatio));

                    drawWaveform(allSampleData);
                    rafPending = false;
                });
            });

            // Mouse dragging for panning
            canvas.addEventListener('mousedown', function (e) {
                if (allSampleData.length === 0) return;
                isDragging = true;
                dragStartX = e.offsetX;
                dragStartSample = viewStartSample;
                canvas.style.cursor = 'grabbing';
            });

            canvas.addEventListener('mousemove', function (e) {
                if (!isDragging || allSampleData.length === 0) return;
                if (rafPending) return;

                rafPending = true;
                requestAnimationFrame(() => {
                    const deltaX = e.offsetX - dragStartX;
                    const canvasWidth = canvas.offsetWidth;
                    const deltaSamples = -(deltaX / canvasWidth) * samplesPerScreen;

                    viewStartSample = Math.max(0, Math.min(allSampleData.length - samplesPerScreen,
                        dragStartSample + deltaSamples));

                    drawWaveform(allSampleData);
                    rafPending = false;
                });
            });

            canvas.addEventListener('mouseup', function () {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });

            canvas.addEventListener('mouseleave', function () {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
        }

        function zoomIn() {
            if (allSampleData.length === 0) return;
            samplesPerScreen = Math.max(100, samplesPerScreen * 0.5);
            viewStartSample = Math.max(0, Math.min(allSampleData.length - samplesPerScreen, viewStartSample));
            drawWaveform(allSampleData);
        }

        function zoomOut() {
            if (allSampleData.length === 0) return;
            samplesPerScreen = Math.min(allSampleData.length, samplesPerScreen * 2);
            viewStartSample = Math.max(0, Math.min(allSampleData.length - samplesPerScreen, viewStartSample));
            drawWaveform(allSampleData);
        }

        function resetZoom() {
            if (allSampleData.length === 0) return;
            viewStartSample = 0;
            samplesPerScreen = Math.min(1000, allSampleData.length);
            drawWaveform(allSampleData);
        }

        async function refreshPorts() {
            try {
                const response = await mockFetch('/api/ports');
                const data = await response.json();

                if (data.success && data.ports.length > 0) {
                    availablePorts = data.ports;
                    const portSelect = document.getElementById('portSelect');
                    portSelect.innerHTML = '';

                    data.ports.forEach((port, index) => {
                        const option = document.createElement('option');
                        option.value = port.device;
                        option.textContent = `${port.device} - ${port.description}`;
                        portSelect.appendChild(option);
                    });

                    addResponse(`Found ${data.ports.length} port(s)`, null, true);
                } else if (data.success && data.ports.length === 0) {
                    const portSelect = document.getElementById('portSelect');
                    portSelect.innerHTML = '<option value="">No devices found</option>';
                    addResponse('⚠️ No matching devices found. Check USB connection.', null, false);
                } else {
                    addResponse('' + data.message, null, false);
                }
            } catch (error) {
                addResponse('Error fetching ports', error.message, false);
            }
        }

        function updateStatus(connected) {
            isConnected = connected;
            const indicator = document.getElementById('statusIndicator');
            const label = document.getElementById('statusLabel');

            if (indicator) {
                indicator.classList.toggle('connected', connected);
                indicator.setAttribute('aria-label', connected ? 'Device connected' : 'Device disconnected');
            }

            if (label) {
                label.textContent = connected ? 'Connected' : 'Disconnected';
            }
        }

        function drawWaveform(dataBytes) {
            const canvas = document.getElementById('waveformCanvas');
            const container = document.getElementById('waveformContainer');
            const sampleInfo = document.getElementById('sampleInfo');

            // Cache context with performance options
            if (!cachedCanvasCtx) {
                cachedCanvasCtx = canvas.getContext('2d', { alpha: false, desynchronized: true });
            }
            const ctx = cachedCanvasCtx;

            // Store all sample data
            allSampleData = dataBytes;

            // Show the canvas container
            container.classList.add('visible');

            // Create grid canvas once
            if (!gridCanvas) {
                gridCanvas = document.createElement('canvas');
                gridCanvas.width = canvas.width;
                gridCanvas.height = canvas.height;
                const gridCtx = gridCanvas.getContext('2d', { alpha: true });

                // Draw grid once to separate canvas
                gridCtx.strokeStyle = 'rgba(56, 189, 248, 0.1)';
                gridCtx.lineWidth = 1;
                for (let i = 0; i < gridCanvas.height; i += 30) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(0, i);
                    gridCtx.lineTo(gridCanvas.width, i);
                    gridCtx.stroke();
                }
                for (let i = 0; i < gridCanvas.width; i += 50) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(i, 0);
                    gridCtx.lineTo(i, gridCanvas.height);
                    gridCtx.stroke();
                }
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw pre-rendered grid
            ctx.drawImage(gridCanvas, 0, 0);

            // Update info display
            const endSample = Math.min(viewStartSample + samplesPerScreen, allSampleData.length);
            sampleInfo.textContent = `Showing samples ${viewStartSample} - ${endSample} of ${allSampleData.length} (${((samplesPerScreen / allSampleData.length) * 100).toFixed(1)}% visible)`;

            // Get the visible portion of data
            const visibleData = allSampleData.slice(viewStartSample, endSample);

            // Downsample if we have more samples than pixels to avoid unnecessary rendering
            const pixelsAvailable = canvas.width;
            let displayData = visibleData;
            let downsampleRatio = 1;

            if (visibleData.length > pixelsAvailable * 2) {
                // Downsample: take max/min for each pixel range to preserve signal features
                downsampleRatio = Math.ceil(visibleData.length / pixelsAvailable);
                displayData = [];
                for (let i = 0; i < visibleData.length; i += downsampleRatio) {
                    const chunk = visibleData.slice(i, i + downsampleRatio);
                    // Store both min and max to preserve edges
                    let minVal = 0xFF, maxVal = 0;
                    for (let j = 0; j < chunk.length; j++) {
                        minVal = Math.min(minVal, chunk[j]);
                        maxVal = Math.max(maxVal, chunk[j]);
                    }
                    displayData.push(maxVal); // Use max value for now
                }
            }

            // Draw 8 channels (bit 0 to bit 7)
            const colors = [
                '#ef4444', '#f97316', '#f59e0b', '#eab308',
                '#84cc16', '#22c55e', '#10b981', '#14b8a6'
            ];

            const channelHeight = canvas.height / 8;

            for (let channel = 0; channel < 8; channel++) {
                ctx.strokeStyle = colors[channel];
                ctx.lineWidth = 2;
                ctx.beginPath();

                const baseY = channelHeight * channel + channelHeight / 2;
                const amplitude = channelHeight * 0.35;

                let prevBit = null;

                for (let x = 0; x < canvas.width; x++) {
                    const sampleIdx = Math.floor(x * displayData.length / canvas.width);
                    if (sampleIdx >= displayData.length) break;

                    const byte = displayData[sampleIdx];
                    const bitValue = (byte >> channel) & 1;
                    const y = baseY - (bitValue ? amplitude : -amplitude);

                    if (x === 0) {
                        ctx.moveTo(x, y);
                        prevBit = bitValue;
                    } else {
                        // Draw vertical line on transitions for digital signal look
                        const prevSampleIdx = Math.floor((x - 1) * displayData.length / canvas.width);
                        const prevByte = displayData[prevSampleIdx];
                        const prevBitValue = (prevByte >> channel) & 1;

                        if (prevBitValue !== bitValue) {
                            ctx.lineTo(x, baseY - (prevBitValue ? amplitude : -amplitude));
                        }
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // Draw channel label with background
                ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
                ctx.fillRect(3, baseY - amplitude - 18, 35, 16);
                ctx.fillStyle = colors[channel];
                ctx.font = 'bold 12px Rajdhani';
                ctx.fillText(`CH${channel}`, 5, baseY - amplitude - 5);
            }

            // Draw time scale markers
            ctx.fillStyle = '#94a3b8';
            ctx.font = 'bold 11px Rajdhani';
            const numMarkers = 10;
            for (let i = 0; i <= numMarkers; i++) {
                const x = (i / numMarkers) * canvas.width;
                const sampleNum = Math.floor(viewStartSample + (i / numMarkers) * samplesPerScreen);
                ctx.fillText(sampleNum.toString(), x + 2, canvas.height - 5);
            }
        }

        function addResponse(message, response, success = true, errorDetails = null, timing = null) {
            const responseBox = document.getElementById('responseBox');
            const time = new Date().toLocaleTimeString();

            const responseItem = document.createElement('div');
            responseItem.className = `response-item ${success ? 'success' : 'error'}`;

            let errorInfo = '';
            if (errorDetails && errorDetails.error_code !== undefined) {
                errorInfo = `
                    <div class="response-data" style="color: #ef4444; font-weight: 600;">
                        Error Code: ${errorDetails.error_code}
                        <br>${errorDetails.error_message || 'Unknown error'}
                    </div>
                `;
            }

            let timingInfo = '';
            if (timing) {
                timingInfo = `
                    <div class="response-data" style="color: #38bdf8; font-weight: 600; font-size: 12px;">
                        Lock: ${timing.lock_wait_ms}ms | Flush: ${timing.flush_time_ms}ms | Write: ${timing.write_time_ms}ms | Response: ${timing.response_wait_ms}ms | Total: ${timing.total_time_ms}ms
                    </div>
                `;
            }

            responseItem.innerHTML = `
                <div class="response-time">${time}</div>
                <div class="response-message">${message}</div>
                ${response ? `<div class="response-data">→ ${response}</div>` : ''}
                ${timingInfo}
                ${errorInfo}
            `;

            // Clear "Waiting for commands..." message
            if (responseBox.children.length === 1 && responseBox.textContent.includes('Awaiting commands')) {
                responseBox.innerHTML = '';
            }

            responseBox.insertBefore(responseItem, responseBox.firstChild);

            // Limit to 50 log entries to prevent performance degradation
            while (responseBox.children.length > 50) {
                responseBox.removeChild(responseBox.lastChild);
            }
        }
        function shouldRunPSUTelemetry() {
            const active = document.querySelector('.tab-panel.active');
            return active && active.id === 'panel-psu';
        }
        async function connectDevice() {
            try {
                const portSelect = document.getElementById('portSelect');
                const selectedPort = portSelect.value;

                if (!selectedPort) {
                    addResponse('Please select a port first', null, false);
                    return;
                }

                const response = await mockFetch('/api/connect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ port: selectedPort })
                });
                const data = await response.json();

                if (data.success) {
                    updateStatus(true);
                    addResponse(data.message, null, true);
                    // Start polling for PSU status once connected
                    //startPsuPolling(); //TODO uncomment
                } else {
                    updateStatus(false);
                    addResponse('' + data.message, null, false);
                    // Stop polling on failure
                    //stopPsuPolling(); //TODO uncomment
                }
            } catch (error) {
                addResponse('Connection error', error.message, false);
                //stopPsuPolling();
            }
        }

        function resetWaveformDefaults() {
            document.getElementById('wfAmplitude').value = 1.0;
            document.getElementById('wfFrequency').value = 1000;
            document.getElementById('wfOffset').value = 0.0;
            document.getElementById('wfPhase').value = 0.0;
            document.getElementById('wfDutyCycle').value = 10.0;
            document.getElementById('wfUpwards').value = 'true';
            addResponse('Waveform parameters reset to defaults', null, true);
        }

        function updateWaveformInputVisibility(type) {
            const dutyCycleGroup = document.getElementById('dutyCycleGroup');
            const rampDirectionGroup = document.getElementById('rampDirectionGroup');

            // Hide all conditional fields first
            dutyCycleGroup.style.display = 'none';
            rampDirectionGroup.style.display = 'none';

            // Show type-specific fields
            if (type === 'pulse') {
                dutyCycleGroup.style.display = 'flex';
            } else if (type === 'ramp') {
                rampDirectionGroup.style.display = 'flex';
            }

            // Highlight active button
            ['sine', 'square', 'triangle', 'ramp', 'pulse'].forEach(waveType => {
                const btn = document.getElementById(`btn-${waveType}`);
                if (btn) {
                    if (waveType === type) {
                        btn.style.boxShadow = '0 0 20px rgba(251, 191, 36, 0.6)';
                        btn.style.borderWidth = '2px';
                    } else {
                        btn.style.boxShadow = '';
                        btn.style.borderWidth = '1px';
                    }
                }
            });
        }

        async function sendWaveform(type) {
            try {
                // Update UI to show type-specific fields
                updateWaveformInputVisibility(type);

                // Gather parameters from input fields
                let amplitude = parseFloat(0);
                let frequency = parseFloat(0);
                let offset = parseFloat(0);
                let phase = parseFloat(0);
                let duty_cycle = parseFloat(0);
                let upwards = parseFloat(0);

                if (type !== 'off') {
                    amplitude = parseFloat(document.getElementById('wfAmplitude').value);
                    frequency = parseFloat(document.getElementById('wfFrequency').value);
                    offset = parseFloat(document.getElementById('wfOffset').value);
                    phase = parseFloat(document.getElementById('wfPhase').value);
                    duty_cycle = parseFloat(document.getElementById('wfDutyCycle').value);
                    upwards = document.getElementById('wfUpwards').value === 'true';
                }
                // Validate parameters
                if (isNaN(amplitude) || isNaN(frequency) || isNaN(offset) || isNaN(phase)) {
                    addResponse('Invalid waveform parameters. Please check your inputs.', null, false);
                    return;
                }

                // Build request body
                const requestBody = {
                    amplitude: amplitude,
                    frequency: frequency,
                    offset: offset,
                    phase: phase,
                    duty_cycle: duty_cycle,
                    upwards: upwards
                };
                let lastType = type;
                if (type === 'off') {
                    type = 'square';
                }

                const response = await mockFetch(`/api/waveform/${type}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                const data = await response.json();
                const shapeLabel = capitalizeWord(type);
                const timeLabel = `Updated ${formatTimeStamp()}`;

                if (data.success) {
                    if (lastType === 'off') {
                        setStatusValue('waveformTypeStatus', 'Idle', 'status-warn');

                        setStatusValue('waveformAmplitudeStatus', '—', null);
                        setStatusValue('waveformFrequencyStatus', '—', null);
                        setStatusValue('waveformUpdateStatus', timeLabel, 'status-good');
                    } else {
                        setStatusValue('waveformTypeStatus', shapeLabel, 'status-good');
                        setStatusValue('waveformAmplitudeStatus', formatVoltage(amplitude), 'status-good');
                        setStatusValue('waveformFrequencyStatus', formatFrequency(frequency), 'status-good');
                        setStatusValue('waveformUpdateStatus', timeLabel, 'status-good');
                    }

                    // Build detailed parameter string for log
                    let paramStr = `Amp: ${amplitude}V, Freq: ${formatFrequency(frequency)}, Offset: ${offset}V, Phase: ${phase}rad`;
                    if (type === 'pulse') {
                        paramStr += `, Duty: ${duty_cycle}%`;
                    } else if (type === 'ramp') {
                        paramStr += `, Dir: ${upwards ? 'Up' : 'Down'}`;
                    }
                    if (lastType === 'off') {
                        addResponse(
                            `Waveform generator turned off`,
                            paramStr,
                            true,
                            data
                        );
                    } else {
                        addResponse(
                            `${data.message}`,
                            paramStr,
                            true,
                            data
                        );
                    }
                } else {
                    setStatusValue('waveformUpdateStatus', 'Command failed', 'status-bad');
                    addResponse('' + data.message, data.response || null, false, data);
                }
            } catch (error) {
                setStatusValue('waveformUpdateStatus', 'Error sending waveform', 'status-bad');
                addResponse('Error sending waveform', error.message, false);
            }
        }

        function setPDProfile(profileID) {

            ppsConfig = document.getElementById("PPSConfig")
            if (profileID != 5) {
                ppsConfig.style.display = 'none';
            } else {
                ppsConfig.style.display = 'block';
            }


            addResponse(`PD profile selected: ${profileID}`, null, true);
        }


        function setVoltage(voltage) {
            document.getElementById('Voltage').value = voltage.toFixed(1);
            setStatusValue('psuVoltageStatus', formatVoltage(voltage), 'status-good');
            addResponse(`Voltage preset selected: ${voltage}V`, null, true);
        }


        //globally store all the psu capabilities for accurate system logs
        let psuCapabilities;
        async function queryPSUCapabilities() {
            console.log("inside query psu capabiulities")
            try {
                const response = await mockFetch('/api/psu/capabilities', {
                    method: 'POST'
                });
                const data = await response.json();
                console.log(data);


                if (data.success && data.capabilities) {
                    // Display capabilities
                    console.log(data.capabilities);
                    psuCapabilities = data.capabilities;
                    displayPSUCapabilities(data.capabilities);

                    //console.log("L2590")
                    addResponse(
                        `${data.message}`,
                        `Profiles: ${data.capabilities.map(c => `${c.voltage_max}V@${c.current_max}A (${c.type})`).join(', ')}`,
                        true
                    );

                    addResponse(
                        `${data.message}`,
                        `Profiles: ${data.capabilities.map(c => `${c.voltage_max}V@${c.current_max}A (${c.type})`).join(', ')}`,
                        true
                    );
                } else {
                    addResponse('' + data.message, null, false, data);
                }
            } catch (error) {
                addResponse('Error querying capabilities', error.message, false);
            }
        }

        function displayPSUCapabilities(capabilities) {
            const panel = document.getElementById('psuCapabilitiesPanel');
            const table = document.getElementById('psuCapabilitiesTable');

            // Clear existing content
            table.innerHTML = '';

            // Create profile items
            console.log("capabilities = ", capabilities)
            capabilities.forEach((cap, index) => {
                const item = document.createElement('div');
                item.className = `psu-profile-item ${cap.type.toLowerCase()}`;
                item.addEventListener("click", function () {
                    // Remove active from all other profile items
                    document.querySelectorAll('.psu-profile-item[active]')
                        .forEach(el => el.removeAttribute('active'));

                    // Add active to this one
                    item.setAttribute("active", "");
                    selectedPDSlot = index;
                    setPDProfile(selectedPDSlot)
                    console.log(selectedPDSlot);
                });

                const typeLabel = cap.type === 'Fixed' ? 'Fixed' : (cap.type === 'PPS' ? 'PPS' : 'Other');

                const voltageDisplay = cap.type !== 'Fixed' && cap.voltage_min
                    ? `${cap.voltage_min}V - ${cap.voltage_max}V`
                    : `${cap.voltage_max}V`;

                item.innerHTML = `
                    <div>
                        <strong>${typeLabel} ${cap.type} Profile (Slot ${cap.slot})</strong>
                        <div class="psu-profile-specs">
                            ${voltageDisplay} @ ${cap.current_max}A (${cap.power_max}W max)
                        </div>
                    </div>
                    <button class="btn-compact psu-btn">
                        Use slot ${cap.slot}
                    </button>
                `;

                table.appendChild(item);
            });

            // Show the panel
            panel.style.display = 'block';
        }

        function updatePSUButtons() {
            const b3 = document.getElementById("btn3V");
            const b5 = document.getElementById("btn5V");
            const b7 = document.getElementById("btnPD");

            // Update 3.3V button style
            if (fixed3VEn) {
                b3.classList.add("psu-btn-on");
                b3.classList.remove("psu-btn-off");
            } else {
                b3.classList.add("psu-btn-off");
                b3.classList.remove("psu-btn-on");
            }

            // Update 5V button style
            if (fixed5VEn) {
                b5.classList.add("psu-btn-on");
                b5.classList.remove("psu-btn-off");
            } else {
                b5.classList.add("psu-btn-off");
                b5.classList.remove("psu-btn-on");
            }

            // Update PD button style
            if (PDEn) {
                b7.classList.add("psu-btn-on");
                b7.classList.remove("psu-btn-off");
            } else {
                b7.classList.add("psu-btn-off");
                b7.classList.remove("psu-btn-on");
            }
        }

        function toggle3V() {
            // Toggle 3.3V
            fixed3VEn = !fixed3VEn;
            updatePSUButtons();
        }

        function toggle5V() {
            // Toggle 5V
            fixed5VEn = !fixed5VEn;
            updatePSUButtons();
        }

        function togglePDOut() {
            // Toggle PD
            PDEn = !PDEn;
            updatePSUButtons();
        }


        async function laStart() {
            try {
                const response = await mockFetch('/api/la/start', {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.success) {
                    setStatusValue('laCaptureStatus', 'Capturing', 'status-good');
                } else {
                    setStatusValue('laCaptureStatus', 'Start failed', 'status-bad');
                }

                addResponse(
                    data.success ? data.message : '' + data.message,
                    data.response || null,
                    data.success,
                    data
                );
            } catch (error) {
                setStatusValue('laCaptureStatus', 'Start error', 'status-bad');
                addResponse('Error starting logic analyzer', error.message, false);
            }
        }

        async function laStop() {
            try {
                const response = await mockFetch('/api/la/stop', {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.success) {
                    setStatusValue('laCaptureStatus', 'Idle', 'status-warn');
                } else {
                    setStatusValue('laCaptureStatus', 'Stop failed', 'status-bad');
                }

                addResponse(
                    data.success ? data.message : '' + data.message,
                    data.response || null,
                    data.success,
                    data
                );
            } catch (error) {
                setStatusValue('laCaptureStatus', 'Stop error', 'status-bad');
                addResponse('Error stopping LA', error.message, false);
            }
        }

        async function laGetChunk() {
            const numChunks = document.getElementById('numChunks').value;

            try {
                const response = await mockFetch('/api/la/get_chunk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ num_chunks: numChunks })
                });
                const data = await response.json();

                if (data.success && data.data_bytes) {
                    // Draw the waveform visualization with ALL data
                    drawWaveform(data.data_bytes);
                    setStatusValue('laCaptureStatus', `Data ${data.total_bytes || data.data_bytes.length} B`, 'status-good');

                    // Format a summary for the log (don't display all bytes in text)
                    let sampleDisplay = `Total bytes: ${data.total_bytes}\n\n`;

                    // Only show first 256 bytes in the hex dump to avoid performance issues
                    const bytesToShow = Math.min(256, data.data_bytes.length);
                    sampleDisplay += `First ${bytesToShow} bytes (hex dump):\n`;

                    // Display as hex dump (16 bytes per line)
                    for (let i = 0; i < bytesToShow; i += 16) {
                        const offset = i.toString(16).padStart(4, '0');
                        const hexBytes = data.data_bytes.slice(i, i + 16)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join(' ');
                        const asciiBytes = data.data_bytes.slice(i, i + 16)
                            .map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.')
                            .join('');

                        sampleDisplay += `${offset}: ${hexBytes.padEnd(48, ' ')} | ${asciiBytes}\n`;
                    }

                    if (data.data_bytes.length > bytesToShow) {
                        sampleDisplay += `\n... (${data.data_bytes.length - bytesToShow} more bytes)\n`;
                        sampleDisplay += `\nAll ${data.data_bytes.length} samples are shown in the waveform above.\n`;
                        sampleDisplay += `Use zoom and pan controls to explore the data.`;
                    }

                    addResponse(
                        data.message,
                        sampleDisplay,
                        true,
                        data
                    );
                } else {
                    addResponse(
                        data.success ? data.message : '' + data.message,
                        data.response || null,
                        data.success,
                        data
                    );
                }
            } catch (error) {
                setStatusValue('laCaptureStatus', 'Data error', 'status-bad');
                addResponse('Error getting chunk', error.message, false);
            }
        }

        async function configurePSU() {
            // selectedPDSlot
            if (selectedPDSlot < 0) {
                addResponse(`Please select a PD Profile first`);
                return;
            }
            //console.log("pd slot = ")
            //console.log( selectedPDSlot)
            let voltage = document.getElementById('Voltage').value;
            let currlim = document.getElementById('Currlim').value;
            //console.log("voltage =")
            //console.log(voltage)

            if (selectedPDSlot != 5) {
                voltage = psuCapabilities[selectedPDSlot].voltage_max;
                currlim = psuCapabilities[selectedPDSlot].current_max;
            }


            try {
                const response = await mockFetch('/api/psu/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ voltage: voltage, current_limit: currlim, pdslot: selectedPDSlot, f3Ven: fixed3VEn, f5Ven: fixed5VEn, pdEN: PDEn })
                });
                const data = await response.json();

                if (data.success) {
                    setStatusValue('psuVoltageStatus', formatVoltage(voltage), 'status-good');
                } else {
                    setStatusValue('psuVoltageStatus', formatVoltage(voltage), 'status-bad');
                }

                addResponse(
                    data.success ? data.message : '' + data.message,
                    data.response || null,
                    data.success,
                    data
                );
            } catch (error) {
                setStatusValue('psuVoltageStatus', 'Error', 'status-bad');
                addResponse('Error configuring voltage', error.message, false);
            }
        }

        async function configureLA() {
            const frequency = document.getElementById('frequency').value;

            try {
                const response = await mockFetch('/api/la/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ frequency: frequency })
                });
                const data = await response.json();

                if (data.success) {
                    setStatusValue('laFrequencyStatus', formatFrequency(frequency), 'status-good');
                } else {
                    setStatusValue('laFrequencyStatus', 'Config error', 'status-bad');
                }

                addResponse(
                    data.success ? data.message : '' + data.message,
                    data.response || null,
                    data.success,
                    data
                );
            } catch (error) {
                setStatusValue('laFrequencyStatus', 'Config error', 'status-bad');
                addResponse('Error configuring LA', error.message, false);
            }
        }

        async function pingDevice() {
            try {
                const response = await mockFetch('/api/ping', {
                    method: 'POST'
                });
                const data = await response.json();

                addResponse(
                    data.success ? data.message : '' + data.message,
                    data.response || null,
                    data.success,
                    null,  // errorDetails
                    data.timing || null  // timing data
                );
            } catch (error) {
                addResponse('Error pinging device', error.message, false);
            }
        }

        async function testUsbSpeed() {
            const testSize = parseInt(document.getElementById('testSizeSelect').value);
            const throughputElement = document.getElementById('usbThroughput');
            const durationElement = document.getElementById('usbDuration');

            // Reset display
            throughputElement.textContent = 'Testing...';
            durationElement.textContent = 'Testing...';

            try {
                const response = await mockFetch('/api/usb/speed_test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ test_size_kb: testSize })
                });
                const data = await response.json();

                if (data.success) {
                    // Update status tiles
                    throughputElement.textContent = `${data.throughput_mbps} MB/s`;
                    durationElement.textContent = `${data.duration_ms} ms`;

                    // Add response to log
                    const details = `Transferred ${data.total_bytes.toLocaleString()} bytes (${data.test_size_kb}KB)\n` +
                        `Throughput: ${data.throughput_mbps} MB/s\n` +
                        `Duration: ${data.duration_ms} ms`;

                    addResponse(
                        'USB speed test complete',
                        details,
                        true,
                        null,
                        data.timing || null
                    );
                } else {
                    throughputElement.textContent = 'Error';
                    durationElement.textContent = 'Error';
                    addResponse('' + data.message, null, false);
                }
            } catch (error) {
                throughputElement.textContent = 'Error';
                durationElement.textContent = 'Error';
                addResponse('Error testing USB speed', error.message, false);
            }
        }

        // --- PSU Status Polling ---
        //let psuStatusInterval;

        function queryPSUStatus() {
            if (!isConnected) return;

            mockFetch('/api/psu/status', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.status) {
                        updatePSUTelemetry(data.status);
                    } else {
                        // Don't log errors on periodic polls to avoid spam
                        // logResponse(`PSU Status Poll Failed: ${data.message || 'No status data'}`, 'error');
                        updatePSUTelemetry(null); // Clear telemetry on error
                    }
                })
                .catch(error => {
                    // logResponse(`PSU Status Poll Error: ${error}`, 'error');
                    updatePSUTelemetry(null); // Clear telemetry on error
                });
        }


        //let psuLifeInterval;
        function queryPSULife() {
            if (!isConnected) return;

            mockFetch('/api/psu/alive', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
                .then(response => response.json())
                .then(data => {

                    if (data.success) {
                        if (isUSBCConnected != data.status) {
                            const psuIndicator = document.getElementById('psuIndicator');
                            psuIndicator.classList.toggle('unstable', data.status == false);
                            if (data.status == false) {
                                console.log("went into if in psu/alive")
                                //collapseSection(document.getElementById("psusec"))
                                selectedPDSlot = -1;
                            } else {
                                console.log("went into else in psu/alive")

                                //expandSection(document.getElementById("psusec"))
                                queryPSUCapabilities()
                            }
                        }

                        isUSBCConnected = (data.status == true)
                    }

                    //On change
                    if (data.success != isPDWFConnected) {
                        if (data.success) {
                            console.log(`PSU Alive: USB connection is ${data.status}`)
                        } else {
                            console.log("PSU DEAD")
                            //collapseSection(document.getElementById("psusec"))
                            //collapseSection(document.getElementById("wavsec"))
                        }

                        const psuIndicator = document.getElementById('psuIndicator');
                        psuIndicator.classList.toggle('connected', data.success);
                        psuIndicator.setAttribute('aria-label', data.success ? 'Device connected' : 'Device disconnected');
                        const wfIndicator = document.getElementById('wfIndicator');
                        wfIndicator.classList.toggle('connected', data.success);
                        wfIndicator.setAttribute('aria-label', data.success ? 'Device connected' : 'Device disconnected');

                    }

                    isPDWFConnected = data.success
                })
                .catch(error => {
                });
        }


        function updatePSUTelemetry(status) {
            const voltageEl = document.getElementById('psu-voltage-actual');
            const currentEl = document.getElementById('psu-current-actual');
            const currentLim = document.getElementById('psu-current-limit');
            const tempEl = document.getElementById('psu-temp');
            const status5VEl = document.getElementById('psu-5v-status');
            const status3V3El = document.getElementById('psu-3v3-status');
            const statusPDEl = document.getElementById('psu-pd-status');
            const voltageReqEl = document.getElementById('psu-voltage-req');

            if (status) {
                voltageEl.textContent = status.voltage_actual.toFixed(2);
                currentEl.textContent = status.current_actual.toFixed(3);
                currentLim.textContent = status.req_current_lim.toFixed(3);
                tempEl.textContent = status.temp_c.toFixed(1);
                voltageReqEl.textContent = status.req_voltage.toFixed(2);

                status5VEl.textContent = status.f5v_enabled ? 'ON' : 'OFF';
                status5VEl.className = `status-value ${status.f5v_enabled ? 'status-good' : 'status-bad'}`;

                status3V3El.textContent = status.f3v_enabled ? 'ON' : 'OFF';
                status3V3El.className = `status-value ${status.f3v_enabled ? 'status-good' : 'status-bad'}`;

                statusPDEl.textContent = status.pd_enabled ? 'ON' : 'OFF';
                statusPDEl.className = `status-value ${status.pd_enabled ? 'status-good' : 'status-bad'}`;

                // Update voltage status color based on how close it is to requested
                const diff = Math.abs(status.voltage_actual - status.req_voltage);
                if (status.req_voltage > 0) {
                    if (diff < 0.1) {
                        voltageEl.classList.add('status-good');
                        voltageEl.classList.remove('status-warn', 'status-bad');
                    } else if (diff < 0.5) {
                        voltageEl.classList.add('status-warn');
                        voltageEl.classList.remove('status-good', 'status-bad');
                    } else {
                        voltageEl.classList.add('status-bad');
                        voltageEl.classList.remove('status-good', 'status-warn');
                    }
                } else {
                    voltageEl.classList.remove('status-good', 'status-warn', 'status-bad');
                }

            } else {
                // Reset to default on error or disconnect
                [voltageEl, currentEl, tempEl, voltageReqEl].forEach(el => el.textContent = '--');
                [status5VEl, status3V3El, statusPDEl].forEach(el => {
                    el.textContent = 'N/A';
                    el.className = 'status-value';
                });
                voltageEl.classList.remove('status-good', 'status-warn', 'status-bad');
            }
        }

        function startPsuPolling() {
            if (psuStatusInterval) clearInterval(psuStatusInterval);
            if (psuLifeInterval) clearInterval(psuLifeInterval);
            // Poll every 2 seconds
            psuStatusInterval = setInterval(queryPSUStatus, 500);
            setTimeout(() => { //offset life query by 500ms
                psuLifeInterval = setInterval(queryPSULife, 500);
            }, 250);
        }

        function stopPsuPolling() {
            if (psuStatusInterval) clearInterval(psuStatusInterval);
            if (psuLifeInterval) clearInterval(psuLifeInterval);
            psuStatusInterval = null;
            psuLifeInterval = null;
            updatePSUTelemetry(null); // Clear data on disconnect
        }

        // --- Document Ready ---
        document.addEventListener('DOMContentLoaded', () => {
            // Start PSU status polling when connected
            const originalConnectDevice = connectDevice.bind(this);
            connectDevice = async function () {
                await originalConnectDevice();
                if (isConnected) {
                    //startPsuPolling();
                } else {
                    //stopPsuPolling();
                }
            };

            // Stop polling on unload
            window.addEventListener('beforeunload', () => {
                stopPsuPolling();
            });
        });
        document.addEventListener('keydown', function (event) {
            // Avoid triggering hotkeys while typing in text/number inputs
            if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

            let targetPanel = null;

            switch (event.key) {
                case '1':
                    targetPanel = 'panel-connection';
                    break;
                case '2':
                    targetPanel = 'panel-psu';
                    break;
                case '3':
                    targetPanel = 'panel-wf';
                    break;
                case '4':
                    targetPanel = 'panel-la';
                    break;
                case '5':
                    targetPanel = 'panel-scope';
                    break;
                default:
                    return; // ignore all other keys
            }

            document.getElementById("vdiv").addEventListener("blur", () => {
                if (lastSamples) drawScopeWaveform(lastSamples);
            });

            document.getElementById("tdiv").addEventListener("blur", () => {
                if (lastSamples) drawScopeWaveform(lastSamples);
            });


            const btn = document.querySelector(`.tab-btn[data-target="${targetPanel}"]`);
            if (btn) {
                btn.click();           // triggers your existing handler
                event.preventDefault(); // avoid scrolling/etc
            }
        });
    </script>
</body>

</html>